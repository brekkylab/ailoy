# System Message

A **system message** defines the global behavior, tone, or role of the
assistant. It provides the language model with high-level instructions such as
_“You are a helpful assistant”_ or _“Answer concisely in JSON format.”_

System messages guide how the model interprets subsequent user inputs and how it
should respond. They are usually placed at the very beginning of the message
array, before any user or assistant messages.

One can override this system message by explicitly including their own in the
first element of the messages array.

{/* prettier-ignore-start */}

```json
[
  {
    "role": "system",
    "contents": [
      {
        "type": "text",
        "text": "You are an assistant who always speaks like a pirate."
      }
    ]
  },
  {
    "role": "user",
    "contents": [
      {
        "type": "text",
        "text": "Explain how memory management works in Rust."
      }
    ]
  }
]
```

{/* prettier-ignore-end */}

The model will now respond according to the pirate persona instead of the
default neutral assistant style:

{/* prettier-ignore-start */}

```json
{
  "role": "assistant",
  "contents": [
    {
      "type": "text",
      "text": "Arrr, matey! In Rust, the seas be ruled by ownership and borrowing. Each variable be owning its treasure, and when it sails out of scope, the booty be dropped overboard — no garbage crew needed!"
    }
  ]
}
```

{/* prettier-ignore-end */}

## Example

{/* prettier-ignore-start */}

<CodeTabs>

```python
import asyncio

import ailoy as ai


async def main():
    lm = await ai.LangModel.new_local("Qwen/Qwen3-0.6B")
    agent = ai.Agent(lm)

    messages = [
        ai.Message(
            role="system",
            # If only one text part in `contents`, it can be written as a single string.
            contents="You are an assistant who always speaks like a pirate.",
        ),
        ai.Message(
            role="user",
            # In general, `contents` are written as a list of `Part`.
            contents=[
                ai.Part.Text(text="Explain how memory management works in Rust.")
            ],
        ),
    ]
    async for resp in agent.run(messages):
        if isinstance(resp.message.contents[0], ai.Part.Text):
            print(resp.message.contents[0].text)


if __name__ == "__main__":
    asyncio.run(main())

```

```typescript
import * as ai from "ailoy-node";

async function main() {
  const lm = await ai.LangModel.newLocal("Qwen/Qwen3-0.6B");
  const agent = new ai.Agent(lm);
  const messages = [
    {
      role: "system",
      // If only one text part in `contents`, it can be written as a single string.
      contents: "You are an assistant who always speaks like a pirate.",
    },
    {
      role: "user",
      // In general, `contents` are written as a list of `Part`.
      contents: [
        { type: "text", text: "Explain how memory management works in Rust." },
      ],
    },
  ] as ai.Messages;
  for await (const resp of agent.run(messages)) {
    if (resp.message.contents[0].type === "text") {
      console.log(resp.message.contents[0].text);
    }
  }
}

main().catch((err) => {
  console.error("Error:", err);
});
```

```typescript web
import * as ai from "ailoy-web";

async function main() {
  const lm = await ai.LangModel.newLocal("Qwen/Qwen3-0.6B");
  const agent = new ai.Agent(lm);
  const messages = [
    {
      role: "system",
      // If only one text part in `contents`, it can be written as a single string.
      contents: "You are an assistant who always speaks like a pirate.",
    },
    {
      role: "user",
      // In general, `contents` are written as a list of `Part`.
      contents: [
        { type: "text", text: "Explain how memory management works in Rust." },
      ],
    },
  ] as ai.Messages;
  for await (const resp of agent.run(messages)) {
    if (resp.message.contents[0].type === "text") {
      console.log(resp.message.contents[0].text);
    }
  }
}

main().catch((err) => {
  console.error("Error:", err);
});
```

</CodeTabs>

{/* prettier-ignore-end */}

<TerminalBox>

Arrr, matey! In Rust, the seas be ruled by ownership and borrowing. Each
variable be owning its treasure, and when it sails out of scope, the booty be
dropped overboard — no garbage crew needed!

</TerminalBox>

The LM will use the developer-defined system message instead of its internal
default, allowing full customization of the model’s tone, persona, or
task-specific behavior.

## Notes

- Always place the system message as **the first message in the sequence**.
  Placing it elsewhere may cause errors or undefined behavior.
- The system message affects all subsequent responses within the same
  conversation.
- If you want to reset or change the system behavior mid-session, you should
  start a new conversation or explicitly include a new `system` role message at
  the beginning of a fresh message list.
