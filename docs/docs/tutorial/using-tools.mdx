# Using Tools

One of the most powerful features in Ailoy is the tool calling system.
It allows you to extend the capabilities of your LLM by connecting it to external tools or APIs.
This way, the agent can access real-time or domain-specific information, even if it wasn’t part of the model’s training data.

To use a Tool, two features must be defined.

#### Tool Description

This explains how the tool works.
Based on this, the LLM determines when and how to call the tool.
A tool description can define parameters and (optionally) return values.

Conventionally, this is represented in JSON Schema, which we also follow.

```json
{
    "name": "temperature",
    "description": "Get current temperature",
    "parameters": {
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "The city name"
            },
            "unit": {
                "type": "string",
                "enum": ["Celsius", "Fahrenheit"]
            }
        },
        "required": ["location", "unit"]
    },
    "returns": {
        "type": "number",
        "description": "Null if the given city name is unavailable.",
        "nullable": true,
    }
}
```

#### Tool Behavior

This defines what the tool actually does when it is invoked.
It is typically implemented as a Python or JavaScript function.

## Example

Now, let's see how to make a _tool-aware agent_ in Ailoy.

In this example, we’ll use the **[Frankfurter API](https://frankfurter.dev/)**
to add functionality to lookup real-time currency exchange rates into your `Agent`.

<CodeTabs>

```python
import ailoy as ai

tool_desc = ai.ToolDesc(
    name="frankfurter",
    description="Get the latest currency exchange rates of target currencies based on the 'base' currency",
    parameters={
        "type": "object",
        "properties": {
            "base": {
                "type": "string",
                "description": "The ISO 4217 currency code to be the divider of the currency rate to be got."
            },
            "symbols": {
                "type": "string",
                "description": "The target ISO 4217 currency codes separated by comma."
            }
        },
    }
)

def tool_behavior(parameters):
    # TBD
    base = parameters["base"]
    symbols = parameters["symbols"]

lm = await ai.LangModel.CreateLocal("Qwen/Qwen3-8B")
tools = [ai.Tool.new_py_function(tool_desc, tool_behavior)]
agent = Agent(lm, tools)
```

```typescript
TBD
```

</CodeTabs>

You can find out what tool the agent invoked and what result it produced through
the response generated by `agent.run()` or `agent.run_delta()`.
The `agent.run()` function includes a field called `tool_calls`.
If this field contains any values, it indicates that the LLM’s output has triggered one or more **tool calls**.

<CodeTabs>

```python
for resp in agent.run(question):
    # skip printing when the response is related to tool calls
    if resp.tool_calls:
        print(resp)
```

```typescript
for await (const resp of agent.run(question)) {
    // skip printing when the response is related to tool calls
    if (resp.tool_calls)
        console.log(resp)
}
```

</CodeTabs>

:::info
When using an `Agent` API, one doesn’t need to do anything for handling tool calls.

The Agent automatically detects the invocation of a tool, call the function of the tool in the next iteration.
:::

Let's see the entire example code using the Frankfurter API tool.

<CodeTabs>

```python
from ailoy import Runtime, Agent, LocalModel

rt = Runtime()

with Agent(rt, LocalModel("Qwen/Qwen3-8B")) as agent:
    # Attach frankfurter's API
    agent.add_tools_from_preset("frankfurter")

    question = "I want to buy 250 U.S. Dollar and 350 Chinese Yuan with my Korean Won. How much do I need to take?"
    print(f"Question: {question}\n")
    for resp in agent.query(question):
        if resp.type == "output_text":
            print(resp.content, end='')
        elif resp.type == "tool_call":
            tool_name = resp.content.function.name
            tool_arguments = resp.content.function.arguments
            print(f"Tool call: {tool_name}({', '.join(f'{k}="{v}"' for k, v in tool_arguments.items())})\n")
        elif resp.type == "tool_call_result":
            tool_result = resp.content
            print(f"Tool result: {tool_result.content}\n")
        else:
            raise TypeError("Unexpected response type.")
    print()

rt.stop()
```

```typescript
import { startRuntime, defineAgent, LocalModel } from "ailoy-node";

(async () => {
  const rt = await startRuntime();

  const agent = await defineAgent(rt, LocalModel({ id: "Qwen/Qwen3-8B" }));

  // Attach frankfurter's API
  agent.addToolsFromPreset("frankfurter");

  const question =
    "I want to buy 250 U.S. Dollar and 350 Chinese Yuan with my Korean Won. How much do I need to take?";
  console.log(`Question: ${question}\n`);
  for await (const resp of agent.query(question)) {
    if (resp.type === "output_text") {
      process.stdout.write(resp.content);
    } else if (resp.type === "tool_call") {
      const toolName = resp.content.function.name;
      const toolArguments = resp.content.function.arguments;
      const argString = Object.entries(toolArguments)
        .map(([k, v]) => `${k}="${v}"`)
        .join(", ");
      console.log(`Tool call: ${toolName}(${argString})\n`);
    } else if (resp.type === "tool_call_result") {
      const toolResult = resp.content;
      console.log(`Tool result: ${toolResult.content}\n`);
    } else {
      throw new TypeError("Unexpected response type.");
    }
  }

  console.log();

  await agent.delete();

  await rt.stop();
})();
```

</CodeTabs>

You can see that the agent uses the Frankfurter API to incorporate real-time
exchange rate information into its response.

Here's what the output will look like:

{/* prettier-ignore-start */}

<TerminalBox>
{`Question: I want to buy 250 U.S. Dollar and 350 Chinese Yuan with my Korean Won. How much do I need to take?

Tool call: frankfurter(symbols="USD,CNY", base="KRW")

Tool result: {"CNY": 0.00518, "USD": 0.00072}

To buy 250 U.S. Dollars (USD) and 350 Chinese Yuan (CNY) using Korean Won (KRW), you need to calculate the total amount of KRW required based on the exchange rates:

- **1 USD = 0.00072 KRW**
- **1 CNY = 0.00518 KRW**

### Calculation:
- **For USD**:  
  $ 250 \\, \\text{USD} \\times \\frac{1}{0.00072} = 250 \\times 1388.89 = 347,222.22 \\, \\text{KRW} $

- **For CNY**:  
  $ 350 \\, \\text{CNY} \\times \\frac{1}{0.00518} = 350 \\times 193.18 = 67,613.39 \\, \\text{KRW} $

### Total:
- **KRW needed**: $ 347,222.22 + 67,613.39 = 414,835.61 \\, \\text{KRW} $

You will need approximately **414,835.61 KRW** to buy 250 USD and 350 CNY.`}

</TerminalBox>

{/* prettier-ignore-end */}
{/* prettier-ignore-start */}

:::warning
Keep in mind: Tools aren't free — every token counts.

Using many tools can generate a large amount of information for the AI to process, potentially leading to longer context lengths and decreased performance.

Whether you're running AI through external APIs or using on-device models, it consumes resources.
API usage can lead to unexpectedly high bills, while on-device AI may slow down your machine or even cause it to crash.
Whether you're using external APIs or running models on-device, resources are consumed. API usage might result in unexpectedly high costs, while on-device models could slow down your machine or even cause it to crash.

Avoid using unnecessary tools. Keep your chat context focused and concise. 
:::

{/* prettier-ignore-end */}
