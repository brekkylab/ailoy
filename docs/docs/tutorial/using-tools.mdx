# Using Tools

One of the most powerful features in Ailoy is the tool calling system. It allows
you to extend your LLM’s capabilities by connecting it with external tools or
APIs. This way, the agent can access real-time or domain-specific information,
even if it wasn’t part of the model’s training data.

To use a tool, two components must be defined: **Tool Descripition** and **Tool
Behavior**.

{/* prettier-ignore-start */}

:::info
Please refer to **[Architecture](../concepts/architecture.mdx#tool)** section for more about the tool architecture.
:::

{/* prettier-ignore-end */}

Now, let's explore how to make a _tool-aware agent_ in Ailoy.

In this example, we’ll use the **[Frankfurter API](https://frankfurter.dev/)**
to enable your agent to look up real-time currency exchange rates.

{/* prettier-ignore-start */}

:::info
Please refer to **[MCP Integration](./mcp-integration.mdx)** section for using MCP tools.
:::

{/* prettier-ignore-end */}

## Step-by-Step Guide

### Defining the Tool Description

A tool description defines how the tool is exposed to the model. It includes the
tool’s name, purpose, parameters, and optionally, its return types. This schema
helps the model understand how to invoke the tool correctly.

Parameters are typically expressed in JSON Schema format.

{/* prettier-ignore-start */}

:::info
You can refer to
**[OpenAI's documentation](https://platform.openai.com/docs/guides/function-calling#defining-functions)**
or
**[Hunggingface's documentation](https://huggingface.co/docs/transformers/v4.38.1/custom_tools#adding-new-tools)**
for more details about defining tools in JSON Schema format.
:::

{/* prettier-ignore-end */}

<CodeTabs>

```python
import ailoy as ai

tool_desc = ai.ToolDesc(
    name="frankfurter",
    description="Get the latest currency exchange rates of target currencies based on the 'base' currency",
    parameters={
        "type": "object",
        "properties": {
            "base": {
                "type": "string",
                "description": "The ISO 4217 currency code to be the divider of the currency rate to be got."
            },
            "symbols": {
                "type": "string",
                "description": "The target ISO 4217 currency codes separated by comma."
            }
        },
    }
)
```

```typescript
const tool_desc: ToolDesc = {
  name: "frankfurter",
  description:
    "Get the latest currency exchange rates of target currencies based on the 'base' currency",
  parameters: {
    type: "object",
    properties: {
      base: {
        type: "string",
        description:
          "The ISO 4217 currency code to be the divider of the currency rate to be got.",
      },
      symbols: {
        type: "string",
        description: "The target ISO 4217 currency codes separated by comma.",
      },
    },
  },
};
```

</CodeTabs>

### Defining the Tool Behavior

A tool behavior defines what the tool actually does when invoked. It represents
the executable logic that runs when the model calls the tool.

The function receives the parameters specified in the tool description and
returns a result that matches the expected schema.

When the agent runs, the model decides when and how to invoke this function
based on the conversation context and the provided tool description.

<CodeTabs>

```python
def tool_behavior(base, symbols):
    if not base:
        raise ValueError("Missing 'base'")
    if not symbols:
        raise ValueError("Missing 'symbols'")

    query = parse.urlencode({"from": base, "to": symbols})
    url = f"https://api.frankfurter.app/latest?{query}"

    try:
        with request.urlopen(url, timeout=10) as resp:
            if resp.status != 200:
                raise RuntimeError(f"Frankfurter API returned HTTP {resp.status}")
            payload = json.loads(resp.read().decode("utf-8"))
    except error.URLError as e:
        raise RuntimeError(f"Failed to reach Frankfurter API: {e}") from e
    except json.JSONDecodeError as e:
        raise RuntimeError("Failed to parse Frankfurter API response as JSON.") from e

    return payload
```

```typescript
async function toolBehavior(args) {
  const { base, symbols } = args;
  if (!base) {
    throw new Error("Missing 'base'");
  }
  if (!symbols) {
    throw new Error("Missing 'symbols'");
  }

  const params = new URLSearchParams({ from: base, to: symbols });
  const url = `https://api.frankfurter.app/latest?${params.toString()}`;

  let resp;
  try {
    resp = await fetch(url, { timeout: 10000 });
  } catch (err) {
    throw new Error(`Failed to reach Frankfurter API: ${err.message}`);
  }

  if (!resp.ok) {
    throw new Error(`Frankfurter API returned HTTP ${resp.status}`);
  }

  try {
    return await resp.json();
  } catch {
    throw new Error("Failed to parse Frankfurter API response as JSON.");
  }
}
```

</CodeTabs>

### Registering the Tool with the Agent

Once the tool is defined, the `Agent` automatically detects when the model
intends to invoke it and executes the corresponding function in the following
iteration.

You can register a tool by passing it to the `Agent` constructor.

<CodeTabs>

```python
lm = await ai.LangModel.new_local("Qwen/Qwen3-8B")
tools = [ai.Tool.new_py_function(tool_behavior, tool_desc)]
agent = ai.Agent(lm, tools)
```

```typescript
const lm = await ai.LangModel.newLocal("Qwen/Qwen3-8B");
const tools = [ai.Tool.newFunction(toolDesc, toolBehavior)];
const agent = new ai.Agent(lm, tools);
```

</CodeTabs>

Also, you can register the tools **after** creating the agent by using the
`add_tool` methods.

<CodeTabs>

```python
lm = await ai.LangModel.new_local("Qwen/Qwen3-8B")
agent = ai.Agent(lm, [])
...
agent.add_tool(ai.Tool.new_py_function(tool_behavior, tool_desc))
```

```typescript
const lm = await ai.LangModel.newLocal("Qwen/Qwen3-8B");
const agent = new ai.Agent(lm);
...
agent.add_tool(ai.Tool.newFunction(toolDesc, toolBehavior));
```

</CodeTabs>

You can check which tool the agent invoked and what result it produced from the
response returned by `agent.run()` or `agent.run_delta()`. The `agent.run()`
function includes a field called `tool_calls`. If this field contains any
values, it indicates that the LLM’s output has triggered one or more **tool
calls**.

## Complete Example

<CodeTabs>

```python
import asyncio
import json
from urllib import error, parse, request

import ailoy as ai

tool_desc = ai.ToolDesc(
    name="frankfurter",
    description="Get the latest currency exchange rates of target currencies based on the 'base' currency",
    parameters={
        "type": "object",
        "properties": {
            "base": {
                "type": "string",
                "description": "The ISO 4217 currency code to be the divider of the currency rate to be got.",
            },
            "symbols": {
                "type": "string",
                "description": "The target ISO 4217 currency codes separated by comma.",
            },
        },
    },
)


def tool_behavior(base, symbols):
    if not base:
        raise ValueError("Missing 'base'")
    if not symbols:
        raise ValueError("Missing 'symbols'")

    query = parse.urlencode({"from": base, "to": symbols})
    url = f"https://api.frankfurter.app/latest?{query}"

    try:
        with request.urlopen(url, timeout=10) as resp:
            if resp.status != 200:
                raise RuntimeError(f"Frankfurter API returned HTTP {resp.status}")
            payload = json.loads(resp.read().decode("utf-8"))
    except error.URLError as e:
        raise RuntimeError(f"Failed to reach Frankfurter API: {e}") from e
    except json.JSONDecodeError as e:
        raise RuntimeError("Failed to parse Frankfurter API response as JSON.") from e

    return payload


async def main():
    lm = await ai.LangModel.new_local("Qwen/Qwen3-8B", None, progress_callback=print)
    tools = [ai.Tool.new_py_function(tool_behavior, tool_desc)]
    agent = ai.Agent(lm, tools)
    query = "I want to buy 250 U.S. Dollar and 350 Chinese Yuan with my Korean Won. How much do I need to take?"
    print("Query:", query, "\n")
    async for resp in agent.run(query):
        if resp.message.role == "assistant":
            if len(resp.message.tool_calls) > 0:
                print("Tool call:", resp.message.tool_calls[0].function, "\n")
            else:
                print(resp.message.contents[0].text, "\n")
        elif resp.message.role == "tool":
            print("Tool response:", resp.message.contents[0].value, "\n")


if __name__ == "__main__":
    asyncio.run(main())
```

```typescript
import * as ai from "ailoy-node";

const toolDesc = {
  name: "frankfurter",
  description:
    "Get the latest currency exchange rates of target currencies based on the 'base' currency",
  parameters: {
    type: "object",
    properties: {
      base: {
        type: "string",
        description:
          "The ISO 4217 currency code to be the divider of the currency rate to be got.",
      },
      symbols: {
        type: "string",
        description: "The target ISO 4217 currency codes separated by comma.",
      },
    },
  },
};

async function toolBehavior(args) {
  const { base, symbols } = args;
  if (!base) {
    throw new Error("Missing 'base'");
  }
  if (!symbols) {
    throw new Error("Missing 'symbols'");
  }

  const params = new URLSearchParams({ from: base, to: symbols });
  const url = `https://api.frankfurter.app/latest?${params.toString()}`;

  let resp;
  try {
    resp = await fetch(url, { timeout: 10000 });
  } catch (err) {
    throw new Error(`Failed to reach Frankfurter API: ${err.message}`);
  }

  if (!resp.ok) {
    throw new Error(`Frankfurter API returned HTTP ${resp.status}`);
  }

  try {
    return await resp.json();
  } catch {
    throw new Error("Failed to parse Frankfurter API response as JSON.");
  }
}

async function main() {
  const lm = await ai.LangModel.newLocal(
    "Qwen/Qwen3-8B",
    undefined,
    console.log
  );
  const tools = [ai.Tool.newFunction(toolDesc, toolBehavior)];
  const agent = new ai.Agent(lm, tools);
  const query =
    "I want to buy 250 U.S. Dollar and 350 Chinese Yuan with my Korean Won. How much do I need to take?";
  for await (const resp of agent.run(query)) {
    if (resp.message.role === "assistant") {
      if (resp.message.tool_calls?.length > 0) {
        console.log("Tool call:", resp.message.tool_calls[0].function, "\n");
      } else {
        console.log(resp.message.contents[0].text, "\n");
      }
    } else if (resp.message.role === "tool") {
      console.log("Tool response:", resp.message.contents[0].value, "\n");
    }
  }
}

main().catch((err) => {
  console.error("Error:", err);
});
```

</CodeTabs>

## Output

You can see that the agent uses the Frankfurter API to include real-time
exchange rate information in its response.

Here's what the output will look like:

{/* prettier-ignore-start */}

<TerminalBox>

{`Query: I want to buy 250 U.S. Dollar and 350 Chinese Yuan with my Korean Won. How much do I need to take?

Tool call: frankfurter(symbols="USD,CNY", base="KRW")

Tool result: {"CNY": 0.00518, "USD": 0.00072}

To buy 250 U.S. Dollars (USD) and 350 Chinese Yuan (CNY) using Korean Won (KRW), you need to calculate the total amount of KRW required based on the exchange rates:

- **1 USD = 0.00072 KRW**
- **1 CNY = 0.00518 KRW**

### Calculation:
- **For USD**:  
  $ 250 \\, \\text{USD} \\times \\frac{1}{0.00072} = 250 \\times 1388.89 = 347,222.22 \\, \\text{KRW} $

- **For CNY**:  
  $ 350 \\, \\text{CNY} \\times \\frac{1}{0.00518} = 350 \\times 193.18 = 67,613.39 \\, \\text{KRW} $

### Total:
- **KRW needed**: $ 347,222.22 + 67,613.39 = 414,835.61 \\, \\text{KRW} $

You will need approximately **414,835.61 KRW** to buy 250 USD and 350 CNY.`}

</TerminalBox>

{/* prettier-ignore-end */}
{/* prettier-ignore-start */}

:::warning
Keep in mind: Tools aren't free — every token counts.

Using many tools can generate a large amount of information for the AI to process, potentially leading to longer context lengths and decreased performance.

Using tools consumes tokens.
API calls may lead to unexpected costs, while on-device models can slow down your machine or even cause crashes.

Avoid using unnecessary tools. Keep your chat context focused and concise. 
:::

{/* prettier-ignore-end */}
