{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ailoy Python API Reference","text":""},{"location":"#ailoy.Agent","title":"Agent","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Agent:\n    @property\n    def lm(self) -&gt; LangModel: ...\n    @property\n    def tools(self) -&gt; builtins.list[Tool]: ...\n    def __new__(cls, lm: LangModel, tools: typing.Optional[typing.Sequence[Tool]] = None) -&gt; Agent: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    def add_tools(self, tools: typing.Sequence[Tool]) -&gt; None: ...\n    def add_tool(self, tool: Tool) -&gt; None: ...\n    def remove_tools(self, tool_names: typing.Sequence[builtins.str]) -&gt; None: ...\n    def remove_tool(self, tool_name: builtins.str) -&gt; None: ...\n    def run(self, messages: str | list[Message], config: typing.Optional[InferenceConfig] = None) -&gt; AgentRunIterator: ...\n    def run_sync(self, messages: str | list[Message], config: typing.Optional[InferenceConfig] = None) -&gt; AgentRunSyncIterator: ...\n</code></pre>"},{"location":"#ailoy.Agent.lm","title":"lm  <code>property</code>","text":"<pre><code>lm: LangModel\n</code></pre>"},{"location":"#ailoy.Agent.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: list[Tool]\n</code></pre>"},{"location":"#ailoy.Agent.add_tool","title":"add_tool","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def add_tool(self, tool: Tool) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.Agent.add_tools","title":"add_tools","text":"<pre><code>add_tools(tools: Sequence[Tool]) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def add_tools(self, tools: typing.Sequence[Tool]) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.Agent.remove_tool","title":"remove_tool","text":"<pre><code>remove_tool(tool_name: str) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def remove_tool(self, tool_name: builtins.str) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.Agent.remove_tools","title":"remove_tools","text":"<pre><code>remove_tools(tool_names: Sequence[str]) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def remove_tools(self, tool_names: typing.Sequence[builtins.str]) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.Agent.run","title":"run","text":"<pre><code>run(\n    messages: str | list[Message],\n    config: Optional[InferenceConfig] = None,\n) -&gt; AgentRunIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def run(self, messages: str | list[Message], config: typing.Optional[InferenceConfig] = None) -&gt; AgentRunIterator: ...\n</code></pre>"},{"location":"#ailoy.Agent.run_sync","title":"run_sync","text":"<pre><code>run_sync(\n    messages: str | list[Message],\n    config: Optional[InferenceConfig] = None,\n) -&gt; AgentRunSyncIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def run_sync(self, messages: str | list[Message], config: typing.Optional[InferenceConfig] = None) -&gt; AgentRunSyncIterator: ...\n</code></pre>"},{"location":"#ailoy.AgentResponse","title":"AgentResponse","text":"<p>The yielded value from agent.run().</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass AgentResponse:\n    r\"\"\"\n    The yielded value from agent.run().\n    \"\"\"\n    @property\n    def delta(self) -&gt; MessageDelta:\n        r\"\"\"\n        The message delta per iteration.\n        \"\"\"\n    @property\n    def finish_reason(self) -&gt; typing.Optional[FinishReason]:\n        r\"\"\"\n        Optional finish reason. If this is Some, the message accumulation is finalized and stored in `accumulated`.\n        \"\"\"\n    @property\n    def accumulated(self) -&gt; typing.Optional[Message]:\n        r\"\"\"\n        Optional accumulated message.\n        \"\"\"\n    def __repr__(self) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.AgentResponse.accumulated","title":"accumulated  <code>property</code>","text":"<pre><code>accumulated: Optional[Message]\n</code></pre> <p>Optional accumulated message.</p>"},{"location":"#ailoy.AgentResponse.delta","title":"delta  <code>property</code>","text":"<pre><code>delta: MessageDelta\n</code></pre> <p>The message delta per iteration.</p>"},{"location":"#ailoy.AgentResponse.finish_reason","title":"finish_reason  <code>property</code>","text":"<pre><code>finish_reason: Optional[FinishReason]\n</code></pre> <p>Optional finish reason. If this is Some, the message accumulation is finalized and stored in <code>accumulated</code>.</p>"},{"location":"#ailoy.AgentRunIterator","title":"AgentRunIterator","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass AgentRunIterator:\n    def __aiter__(self) -&gt; AgentRunIterator: ...\n    def __anext__(self) -&gt; typing.Awaitable[AgentResponse]: ...\n</code></pre>"},{"location":"#ailoy.AgentRunIterator.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; AgentRunIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __aiter__(self) -&gt; AgentRunIterator: ...\n</code></pre>"},{"location":"#ailoy.AgentRunIterator.__anext__","title":"__anext__","text":"<pre><code>__anext__() -&gt; Awaitable[AgentResponse]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __anext__(self) -&gt; typing.Awaitable[AgentResponse]: ...\n</code></pre>"},{"location":"#ailoy.AgentRunSyncIterator","title":"AgentRunSyncIterator","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass AgentRunSyncIterator:\n    def __iter__(self) -&gt; AgentRunSyncIterator: ...\n    def __next__(self) -&gt; AgentResponse: ...\n</code></pre>"},{"location":"#ailoy.AgentRunSyncIterator.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; AgentRunSyncIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __iter__(self) -&gt; AgentRunSyncIterator: ...\n</code></pre>"},{"location":"#ailoy.AgentRunSyncIterator.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; AgentResponse\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __next__(self) -&gt; AgentResponse: ...\n</code></pre>"},{"location":"#ailoy.CacheProgress","title":"CacheProgress","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass CacheProgress:\n    @property\n    def comment(self) -&gt; builtins.str: ...\n    @property\n    def current(self) -&gt; builtins.int: ...\n    @property\n    def total(self) -&gt; builtins.int: ...\n    def __repr__(self) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.CacheProgress.comment","title":"comment  <code>property</code>","text":"<pre><code>comment: str\n</code></pre>"},{"location":"#ailoy.CacheProgress.current","title":"current  <code>property</code>","text":"<pre><code>current: int\n</code></pre>"},{"location":"#ailoy.CacheProgress.total","title":"total  <code>property</code>","text":"<pre><code>total: int\n</code></pre>"},{"location":"#ailoy.Document","title":"Document","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Document:\n    def __eq__(self, other: builtins.object) -&gt; builtins.bool: ...\n    def __new__(cls, id: builtins.str, text: builtins.str, title: typing.Optional[builtins.str] = None) -&gt; Document: ...\n</code></pre>"},{"location":"#ailoy.DocumentPolyfill","title":"DocumentPolyfill","text":"<p>Provides a polyfill for LLMs that do not natively support the Document feature.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass DocumentPolyfill:\n    r\"\"\"\n    Provides a polyfill for LLMs that do not natively support the Document feature.\n    \"\"\"\n    @property\n    def system_message_template(self) -&gt; typing.Optional[builtins.str]: ...\n    @system_message_template.setter\n    def system_message_template(self, value: typing.Optional[builtins.str]) -&gt; None: ...\n    @property\n    def query_message_template(self) -&gt; typing.Optional[builtins.str]: ...\n    @query_message_template.setter\n    def query_message_template(self, value: typing.Optional[builtins.str]) -&gt; None: ...\n    def __new__(cls) -&gt; DocumentPolyfill: ...\n</code></pre>"},{"location":"#ailoy.DocumentPolyfill.query_message_template","title":"query_message_template  <code>property</code> <code>writable</code>","text":"<pre><code>query_message_template: Optional[str]\n</code></pre>"},{"location":"#ailoy.DocumentPolyfill.system_message_template","title":"system_message_template  <code>property</code> <code>writable</code>","text":"<pre><code>system_message_template: Optional[str]\n</code></pre>"},{"location":"#ailoy.EmbeddingModel","title":"EmbeddingModel","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass EmbeddingModel:\n    @classmethod\n    def new_local(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; typing.Awaitable[EmbeddingModel]: ...\n    @classmethod\n    def new_local_sync(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; EmbeddingModel: ...\n    async def run(self, text: builtins.str) -&gt; builtins.list[float]: ...\n    def run_sync(self, text: builtins.str) -&gt; builtins.list[float]: ...\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.new_local","title":"new_local  <code>classmethod</code>","text":"<pre><code>new_local(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; Awaitable[EmbeddingModel]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_local(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; typing.Awaitable[EmbeddingModel]: ...\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.new_local_sync","title":"new_local_sync  <code>classmethod</code>","text":"<pre><code>new_local_sync(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; EmbeddingModel\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_local_sync(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; EmbeddingModel: ...\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.run","title":"run  <code>async</code>","text":"<pre><code>run(text: str) -&gt; list[float]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>async def run(self, text: builtins.str) -&gt; builtins.list[float]: ...\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.run_sync","title":"run_sync","text":"<pre><code>run_sync(text: str) -&gt; list[float]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def run_sync(self, text: builtins.str) -&gt; builtins.list[float]: ...\n</code></pre>"},{"location":"#ailoy.FinishReason","title":"FinishReason","text":"<p>               Bases: <code>Enum</code></p> <p>Explains why a language model's streamed generation finished.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass FinishReason(enum.Enum):\n    r\"\"\"\n    Explains why a language model's streamed generation finished.\n    \"\"\"\n    Stop = ...\n    r\"\"\"\n    The model stopped naturally (e.g., EOS token or stop sequence).\n    \"\"\"\n    Length = ...\n    r\"\"\"\n    Hit the maximum token/length limit.\n    \"\"\"\n    ToolCall = ...\n    r\"\"\"\n    Stopped because a tool call was produced, waiting for it's execution.\n    \"\"\"\n    Refusal = ...\n    r\"\"\"\n    Content was refused/filtered; string provides reason.\n    \"\"\"\n\n    def __repr__(self) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.FinishReason.Length","title":"Length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Length = ...\n</code></pre> <p>Hit the maximum token/length limit.</p>"},{"location":"#ailoy.FinishReason.Refusal","title":"Refusal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Refusal = ...\n</code></pre> <p>Content was refused/filtered; string provides reason.</p>"},{"location":"#ailoy.FinishReason.Stop","title":"Stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Stop = ...\n</code></pre> <p>The model stopped naturally (e.g., EOS token or stop sequence).</p>"},{"location":"#ailoy.FinishReason.ToolCall","title":"ToolCall  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ToolCall = ...\n</code></pre> <p>Stopped because a tool call was produced, waiting for it's execution.</p>"},{"location":"#ailoy.Grammar","title":"Grammar","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>class Grammar:\n    @typing.final\n    class Plain(Grammar):\n        __match_args__ = ()\n        def __new__(cls) -&gt; Grammar.Plain: ...\n\n    @typing.final\n    class JSON(Grammar):\n        __match_args__ = ()\n        def __new__(cls) -&gt; Grammar.JSON: ...\n\n    @typing.final\n    class JSONSchema(Grammar):\n        __match_args__ = (\"schema\",)\n        @property\n        def schema(self) -&gt; builtins.str: ...\n        def __new__(cls, schema: builtins.str) -&gt; Grammar.JSONSchema: ...\n\n    @typing.final\n    class Regex(Grammar):\n        __match_args__ = (\"regex\",)\n        @property\n        def regex(self) -&gt; builtins.str: ...\n        def __new__(cls, regex: builtins.str) -&gt; Grammar.Regex: ...\n\n    @typing.final\n    class CFG(Grammar):\n        __match_args__ = (\"cfg\",)\n        @property\n        def cfg(self) -&gt; builtins.str: ...\n        def __new__(cls, cfg: builtins.str) -&gt; Grammar.CFG: ...\n\n    ...\n</code></pre>"},{"location":"#ailoy.Grammar.CFG","title":"CFG","text":"<p>               Bases: <code>Grammar</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass CFG(Grammar):\n    __match_args__ = (\"cfg\",)\n    @property\n    def cfg(self) -&gt; builtins.str: ...\n    def __new__(cls, cfg: builtins.str) -&gt; Grammar.CFG: ...\n</code></pre>"},{"location":"#ailoy.Grammar.CFG.cfg","title":"cfg  <code>property</code>","text":"<pre><code>cfg: str\n</code></pre>"},{"location":"#ailoy.Grammar.JSON","title":"JSON","text":"<p>               Bases: <code>Grammar</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass JSON(Grammar):\n    __match_args__ = ()\n    def __new__(cls) -&gt; Grammar.JSON: ...\n</code></pre>"},{"location":"#ailoy.Grammar.JSONSchema","title":"JSONSchema","text":"<p>               Bases: <code>Grammar</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass JSONSchema(Grammar):\n    __match_args__ = (\"schema\",)\n    @property\n    def schema(self) -&gt; builtins.str: ...\n    def __new__(cls, schema: builtins.str) -&gt; Grammar.JSONSchema: ...\n</code></pre>"},{"location":"#ailoy.Grammar.JSONSchema.schema","title":"schema  <code>property</code>","text":"<pre><code>schema: str\n</code></pre>"},{"location":"#ailoy.Grammar.Plain","title":"Plain","text":"<p>               Bases: <code>Grammar</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Plain(Grammar):\n    __match_args__ = ()\n    def __new__(cls) -&gt; Grammar.Plain: ...\n</code></pre>"},{"location":"#ailoy.Grammar.Regex","title":"Regex","text":"<p>               Bases: <code>Grammar</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Regex(Grammar):\n    __match_args__ = (\"regex\",)\n    @property\n    def regex(self) -&gt; builtins.str: ...\n    def __new__(cls, regex: builtins.str) -&gt; Grammar.Regex: ...\n</code></pre>"},{"location":"#ailoy.Grammar.Regex.regex","title":"regex  <code>property</code>","text":"<pre><code>regex: str\n</code></pre>"},{"location":"#ailoy.InferenceConfig","title":"InferenceConfig","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass InferenceConfig:\n    @property\n    def document_polyfill(self) -&gt; typing.Optional[DocumentPolyfill]: ...\n    @document_polyfill.setter\n    def document_polyfill(self, value: typing.Optional[DocumentPolyfill]) -&gt; None: ...\n    @property\n    def think_effort(self) -&gt; typing.Optional[typing.Literal[\"disable\", \"enable\", \"low\", \"medium\", \"high\"]]: ...\n    @think_effort.setter\n    def think_effort(self, value: typing.Optional[typing.Literal[\"disable\", \"enable\", \"low\", \"medium\", \"high\"]]) -&gt; None: ...\n    @property\n    def temperature(self) -&gt; typing.Optional[builtins.float]: ...\n    @temperature.setter\n    def temperature(self, value: typing.Optional[builtins.float]) -&gt; None: ...\n    @property\n    def top_p(self) -&gt; typing.Optional[builtins.float]: ...\n    @top_p.setter\n    def top_p(self, value: typing.Optional[builtins.float]) -&gt; None: ...\n    @property\n    def max_tokens(self) -&gt; typing.Optional[builtins.int]: ...\n    @max_tokens.setter\n    def max_tokens(self, value: typing.Optional[builtins.int]) -&gt; None: ...\n    @property\n    def grammar(self) -&gt; typing.Optional[Grammar]: ...\n    @grammar.setter\n    def grammar(self, value: typing.Optional[Grammar]) -&gt; None: ...\n    def __new__(cls, document_polyfill: typing.Optional[DocumentPolyfill] = None, think_effort: typing.Optional[typing.Literal[\"disable\", \"enable\", \"low\", \"medium\", \"high\"]] = None, temperature: typing.Optional[builtins.float] = None, top_p: typing.Optional[builtins.float] = None, max_tokens: typing.Optional[builtins.int] = None) -&gt; InferenceConfig: ...\n</code></pre>"},{"location":"#ailoy.InferenceConfig.document_polyfill","title":"document_polyfill  <code>property</code> <code>writable</code>","text":"<pre><code>document_polyfill: Optional[DocumentPolyfill]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.grammar","title":"grammar  <code>property</code> <code>writable</code>","text":"<pre><code>grammar: Optional[Grammar]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.max_tokens","title":"max_tokens  <code>property</code> <code>writable</code>","text":"<pre><code>max_tokens: Optional[int]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.temperature","title":"temperature  <code>property</code> <code>writable</code>","text":"<pre><code>temperature: Optional[float]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.think_effort","title":"think_effort  <code>property</code> <code>writable</code>","text":"<pre><code>think_effort: Optional[\n    Literal[\"disable\", \"enable\", \"low\", \"medium\", \"high\"]\n]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.top_p","title":"top_p  <code>property</code> <code>writable</code>","text":"<pre><code>top_p: Optional[float]\n</code></pre>"},{"location":"#ailoy.Knowledge","title":"Knowledge","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Knowledge:\n    @classmethod\n    def new_vector_store(cls, store: VectorStore, embedding_model: EmbeddingModel) -&gt; Knowledge: ...\n    async def retrieve(self, query: builtins.str, config: KnowledgeConfig) -&gt; builtins.list[Document]: ...\n    def as_tool(self) -&gt; Tool: ...\n</code></pre>"},{"location":"#ailoy.Knowledge.as_tool","title":"as_tool","text":"<pre><code>as_tool() -&gt; Tool\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def as_tool(self) -&gt; Tool: ...\n</code></pre>"},{"location":"#ailoy.Knowledge.new_vector_store","title":"new_vector_store  <code>classmethod</code>","text":"<pre><code>new_vector_store(\n    store: VectorStore, embedding_model: EmbeddingModel\n) -&gt; Knowledge\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_vector_store(cls, store: VectorStore, embedding_model: EmbeddingModel) -&gt; Knowledge: ...\n</code></pre>"},{"location":"#ailoy.Knowledge.retrieve","title":"retrieve  <code>async</code>","text":"<pre><code>retrieve(\n    query: str, config: KnowledgeConfig\n) -&gt; list[Document]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>async def retrieve(self, query: builtins.str, config: KnowledgeConfig) -&gt; builtins.list[Document]: ...\n</code></pre>"},{"location":"#ailoy.KnowledgeConfig","title":"KnowledgeConfig","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass KnowledgeConfig:\n    ...\n</code></pre>"},{"location":"#ailoy.LangModel","title":"LangModel","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass LangModel:\n    @classmethod\n    def new_local(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; typing.Awaitable[LangModel]: ...\n    @classmethod\n    def new_local_sync(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; LangModel: ...\n    @classmethod\n    def new_stream_api(cls, spec: typing.Literal[\"ChatCompletion\", \"OpenAI\", \"Gemini\", \"Claude\", \"Responses\", \"Grok\"], model_name: builtins.str, api_key: builtins.str) -&gt; LangModel: ...\n    def run(self, messages: str | list[Message], tools: typing.Optional[typing.Sequence[ToolDesc]] = None, documents: typing.Optional[typing.Sequence[Document]] = None, config: typing.Optional[InferenceConfig] = None) -&gt; LangModelRunIterator: ...\n    def run_sync(self, messages: str | list[Message], tools: typing.Optional[typing.Sequence[ToolDesc]] = None, documents: typing.Optional[typing.Sequence[Document]] = None, config: typing.Optional[InferenceConfig] = None) -&gt; LangModelRunSyncIterator: ...\n    def __repr__(self) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.LangModel.new_local","title":"new_local  <code>classmethod</code>","text":"<pre><code>new_local(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; Awaitable[LangModel]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_local(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; typing.Awaitable[LangModel]: ...\n</code></pre>"},{"location":"#ailoy.LangModel.new_local_sync","title":"new_local_sync  <code>classmethod</code>","text":"<pre><code>new_local_sync(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; LangModel\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_local_sync(cls, model_name: builtins.str, progress_callback: typing.Callable[[CacheProgress], None] = None) -&gt; LangModel: ...\n</code></pre>"},{"location":"#ailoy.LangModel.new_stream_api","title":"new_stream_api  <code>classmethod</code>","text":"<pre><code>new_stream_api(\n    spec: Literal[\n        \"ChatCompletion\",\n        \"OpenAI\",\n        \"Gemini\",\n        \"Claude\",\n        \"Responses\",\n        \"Grok\",\n    ],\n    model_name: str,\n    api_key: str,\n) -&gt; LangModel\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_stream_api(cls, spec: typing.Literal[\"ChatCompletion\", \"OpenAI\", \"Gemini\", \"Claude\", \"Responses\", \"Grok\"], model_name: builtins.str, api_key: builtins.str) -&gt; LangModel: ...\n</code></pre>"},{"location":"#ailoy.LangModel.run","title":"run","text":"<pre><code>run(\n    messages: str | list[Message],\n    tools: Optional[Sequence[ToolDesc]] = None,\n    documents: Optional[Sequence[Document]] = None,\n    config: Optional[InferenceConfig] = None,\n) -&gt; LangModelRunIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def run(self, messages: str | list[Message], tools: typing.Optional[typing.Sequence[ToolDesc]] = None, documents: typing.Optional[typing.Sequence[Document]] = None, config: typing.Optional[InferenceConfig] = None) -&gt; LangModelRunIterator: ...\n</code></pre>"},{"location":"#ailoy.LangModel.run_sync","title":"run_sync","text":"<pre><code>run_sync(\n    messages: str | list[Message],\n    tools: Optional[Sequence[ToolDesc]] = None,\n    documents: Optional[Sequence[Document]] = None,\n    config: Optional[InferenceConfig] = None,\n) -&gt; LangModelRunSyncIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def run_sync(self, messages: str | list[Message], tools: typing.Optional[typing.Sequence[ToolDesc]] = None, documents: typing.Optional[typing.Sequence[Document]] = None, config: typing.Optional[InferenceConfig] = None) -&gt; LangModelRunSyncIterator: ...\n</code></pre>"},{"location":"#ailoy.LangModelRunIterator","title":"LangModelRunIterator","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass LangModelRunIterator:\n    def __aiter__(self) -&gt; LangModelRunIterator: ...\n    def __anext__(self) -&gt; typing.Awaitable[MessageOutput]: ...\n</code></pre>"},{"location":"#ailoy.LangModelRunIterator.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; LangModelRunIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __aiter__(self) -&gt; LangModelRunIterator: ...\n</code></pre>"},{"location":"#ailoy.LangModelRunIterator.__anext__","title":"__anext__","text":"<pre><code>__anext__() -&gt; Awaitable[MessageOutput]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __anext__(self) -&gt; typing.Awaitable[MessageOutput]: ...\n</code></pre>"},{"location":"#ailoy.LangModelRunSyncIterator","title":"LangModelRunSyncIterator","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass LangModelRunSyncIterator:\n    def __iter__(self) -&gt; LangModelRunSyncIterator: ...\n    def __next__(self) -&gt; MessageOutput: ...\n</code></pre>"},{"location":"#ailoy.LangModelRunSyncIterator.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; LangModelRunSyncIterator\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __iter__(self) -&gt; LangModelRunSyncIterator: ...\n</code></pre>"},{"location":"#ailoy.LangModelRunSyncIterator.__next__","title":"__next__","text":"<pre><code>__next__() -&gt; MessageOutput\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __next__(self) -&gt; MessageOutput: ...\n</code></pre>"},{"location":"#ailoy.MCPClient","title":"MCPClient","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass MCPClient:\n    @property\n    def tools(self) -&gt; builtins.list[Tool]: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    @classmethod\n    def from_stdio(cls, command: builtins.str, args: typing.Sequence[builtins.str]) -&gt; typing.Awaitable[MCPClient]: ...\n    @classmethod\n    def from_streamable_http(cls, url: builtins.str) -&gt; typing.Awaitable[MCPClient]: ...\n    def get_tool(self, name: builtins.str) -&gt; typing.Optional[Tool]: ...\n</code></pre>"},{"location":"#ailoy.MCPClient.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: list[Tool]\n</code></pre>"},{"location":"#ailoy.MCPClient.from_stdio","title":"from_stdio  <code>classmethod</code>","text":"<pre><code>from_stdio(\n    command: str, args: Sequence[str]\n) -&gt; Awaitable[MCPClient]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef from_stdio(cls, command: builtins.str, args: typing.Sequence[builtins.str]) -&gt; typing.Awaitable[MCPClient]: ...\n</code></pre>"},{"location":"#ailoy.MCPClient.from_streamable_http","title":"from_streamable_http  <code>classmethod</code>","text":"<pre><code>from_streamable_http(url: str) -&gt; Awaitable[MCPClient]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef from_streamable_http(cls, url: builtins.str) -&gt; typing.Awaitable[MCPClient]: ...\n</code></pre>"},{"location":"#ailoy.MCPClient.get_tool","title":"get_tool","text":"<pre><code>get_tool(name: str) -&gt; Optional[Tool]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def get_tool(self, name: builtins.str) -&gt; typing.Optional[Tool]: ...\n</code></pre>"},{"location":"#ailoy.Message","title":"Message","text":"<p>A chat message generated by a user, model, or tool.</p> <p><code>Message</code> is the concrete, non-streaming container used by the application to store, transmit, or feed structured content into models or tools. It can represent various kinds of messages, including user input, assistant responses, tool-call outputs, or signed thinking metadata.</p> <p>Note that many different kinds of messages can be produced. For example, a language model may internally generate a <code>thinking</code> trace before emitting its final output, in order to improve reasoning accuracy. In other cases, a model may produce function calls \u2014 structured outputs that instruct external tools to perform specific actions.</p> <p>This struct is designed to handle all of these situations in a unified way.</p>"},{"location":"#ailoy.Message--example","title":"Example","text":""},{"location":"#ailoy.Message--rust","title":"Rust","text":"<pre><code>let msg = Message::new(Role::User).with_contents([Part::text(\"hello\")]);\nassert_eq!(msg.role, Role::User);\nassert_eq!(msg.contents.len(), 1);\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Message:\n    r\"\"\"\n    A chat message generated by a user, model, or tool.\n\n    `Message` is the concrete, non-streaming container used by the application to store, transmit, or feed structured content into models or tools.\n    It can represent various kinds of messages, including user input, assistant responses, tool-call outputs, or signed *thinking* metadata.\n\n    Note that many different kinds of messages can be produced.\n    For example, a language model may internally generate a `thinking` trace before emitting its final output, in order to improve reasoning accuracy.\n    In other cases, a model may produce *function calls* \u2014 structured outputs that instruct external tools to perform specific actions.\n\n    This struct is designed to handle all of these situations in a unified way.\n\n    # Example\n\n    ## Rust\n    ```rust\n    let msg = Message::new(Role::User).with_contents([Part::text(\"hello\")]);\n    assert_eq!(msg.role, Role::User);\n    assert_eq!(msg.contents.len(), 1);\n    ```\n    \"\"\"\n    @property\n    def role(self) -&gt; typing.Literal[\"system\", \"user\", \"assistant\", \"tool\"]:\n        r\"\"\"\n        Author of the message.\n        \"\"\"\n    @role.setter\n    def role(self, value: typing.Literal[\"system\", \"user\", \"assistant\", \"tool\"]) -&gt; None:\n        r\"\"\"\n        Author of the message.\n        \"\"\"\n    @property\n    def contents(self) -&gt; builtins.list[Part]:\n        r\"\"\"\n        Primary message parts (e.g., text, image, value, or function).\n        \"\"\"\n    @contents.setter\n    def contents(self, value: typing.Optional[str | list[Part]]) -&gt; None: ...\n    @property\n    def id(self) -&gt; typing.Optional[builtins.str]:\n        r\"\"\"\n        Optional stable identifier for deduplication or threading.\n        \"\"\"\n    @id.setter\n    def id(self, value: typing.Optional[builtins.str]) -&gt; None:\n        r\"\"\"\n        Optional stable identifier for deduplication or threading.\n        \"\"\"\n    @property\n    def thinking(self) -&gt; typing.Optional[builtins.str]:\n        r\"\"\"\n        Internal \u201cthinking\u201d text used by some models before producing final output.\n        \"\"\"\n    @thinking.setter\n    def thinking(self, value: typing.Optional[builtins.str]) -&gt; None:\n        r\"\"\"\n        Internal \u201cthinking\u201d text used by some models before producing final output.\n        \"\"\"\n    @property\n    def tool_calls(self) -&gt; typing.Optional[builtins.list[Part]]:\n        r\"\"\"\n        Tool-call parts emitted alongside the main contents.\n        \"\"\"\n    @tool_calls.setter\n    def tool_calls(self, value: typing.Optional[builtins.list[Part]]) -&gt; None:\n        r\"\"\"\n        Tool-call parts emitted alongside the main contents.\n        \"\"\"\n    @property\n    def signature(self) -&gt; typing.Optional[builtins.str]:\n        r\"\"\"\n        Optional signature for the `thinking` field.\n\n        This is only applicable to certain LLM APIs that require a signature as part of the `thinking` payload.\n        \"\"\"\n    @signature.setter\n    def signature(self, value: typing.Optional[builtins.str]) -&gt; None:\n        r\"\"\"\n        Optional signature for the `thinking` field.\n\n        This is only applicable to certain LLM APIs that require a signature as part of the `thinking` payload.\n        \"\"\"\n    def __new__(cls, role: typing.Literal[\"system\", \"user\", \"assistant\", \"tool\"], contents: typing.Optional[str | list[Part]] = None, id: typing.Optional[builtins.str] = None, thinking: typing.Optional[builtins.str] = None, tool_calls: typing.Optional[typing.Sequence[Part]] = None, signature: typing.Optional[builtins.str] = None) -&gt; Message: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    def append_tool_call(self, part: Part) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.Message.contents","title":"contents  <code>property</code> <code>writable</code>","text":"<pre><code>contents: list[Part]\n</code></pre> <p>Primary message parts (e.g., text, image, value, or function).</p>"},{"location":"#ailoy.Message.id","title":"id  <code>property</code> <code>writable</code>","text":"<pre><code>id: Optional[str]\n</code></pre> <p>Optional stable identifier for deduplication or threading.</p>"},{"location":"#ailoy.Message.role","title":"role  <code>property</code> <code>writable</code>","text":"<pre><code>role: Literal['system', 'user', 'assistant', 'tool']\n</code></pre> <p>Author of the message.</p>"},{"location":"#ailoy.Message.signature","title":"signature  <code>property</code> <code>writable</code>","text":"<pre><code>signature: Optional[str]\n</code></pre> <p>Optional signature for the <code>thinking</code> field.</p> <p>This is only applicable to certain LLM APIs that require a signature as part of the <code>thinking</code> payload.</p>"},{"location":"#ailoy.Message.thinking","title":"thinking  <code>property</code> <code>writable</code>","text":"<pre><code>thinking: Optional[str]\n</code></pre> <p>Internal \u201cthinking\u201d text used by some models before producing final output.</p>"},{"location":"#ailoy.Message.tool_calls","title":"tool_calls  <code>property</code> <code>writable</code>","text":"<pre><code>tool_calls: Optional[list[Part]]\n</code></pre> <p>Tool-call parts emitted alongside the main contents.</p>"},{"location":"#ailoy.Message.append_tool_call","title":"append_tool_call","text":"<pre><code>append_tool_call(part: Part) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def append_tool_call(self, part: Part) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.MessageDelta","title":"MessageDelta","text":"<p>A streaming, incremental update to a [<code>Message</code>].</p> <p><code>MessageDelta</code> accumulates partial outputs (text chunks, tool-call fragments, IDs, signatures, etc.) until they can be materialized as a full [<code>Message</code>]. It implements [<code>Delta</code>] to support accumulation.</p>"},{"location":"#ailoy.MessageDelta--accumulation-rules","title":"Accumulation Rules","text":"<ul> <li><code>role</code>: merging two distinct roles fails.</li> <li><code>thinking</code>: concatenated in arrival order.</li> <li><code>contents</code>/<code>tool_calls</code>: last element is accumulated with the incoming delta when both are compatible (e.g., Text+Text, Function+Function with matching ID policy), otherwise appended as a new fragment.</li> <li><code>id</code>/<code>signature</code>: last-writer-wins.</li> </ul>"},{"location":"#ailoy.MessageDelta--finalization","title":"Finalization","text":"<ul> <li><code>finish()</code> converts the accumulated deltas into a fully-formed [<code>Message</code>].   Fails if required fields (e.g., <code>role</code>) are missing or inner deltas cannot be finalized.</li> </ul>"},{"location":"#ailoy.MessageDelta--examples","title":"Examples","text":"<pre><code>let d1 = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: \"Hel\".into() }]);\nlet d2 = MessageDelta::new().with_contents([PartDelta::Text { text: \"lo\".into() }]);\n\nlet merged = d1.accumulate(d2).unwrap();\nlet msg = merged.finish().unwrap();\nassert_eq!(msg.contents[0].as_text().unwrap(), \"Hello\");\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass MessageDelta:\n    r\"\"\"\n    A streaming, incremental update to a [`Message`].\n\n    `MessageDelta` accumulates partial outputs (text chunks, tool-call fragments, IDs, signatures, etc.) until they can be materialized as a full [`Message`].\n    It implements [`Delta`] to support accumulation.\n\n    # Accumulation Rules\n    - `role`: merging two distinct roles fails.\n    - `thinking`: concatenated in arrival order.\n    - `contents`/`tool_calls`: last element is accumulated with the incoming delta when both are compatible (e.g., Text+Text, Function+Function with matching ID policy), otherwise appended as a new fragment.\n    - `id`/`signature`: last-writer-wins.\n\n    # Finalization\n    - `finish()` converts the accumulated deltas into a fully-formed [`Message`].\n      Fails if required fields (e.g., `role`) are missing or inner deltas cannot be finalized.\n\n    # Examples\n    ```rust\n    let d1 = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: \"Hel\".into() }]);\n    let d2 = MessageDelta::new().with_contents([PartDelta::Text { text: \"lo\".into() }]);\n\n    let merged = d1.accumulate(d2).unwrap();\n    let msg = merged.finish().unwrap();\n    assert_eq!(msg.contents[0].as_text().unwrap(), \"Hello\");\n    ```\n    \"\"\"\n    @property\n    def role(self) -&gt; typing.Optional[typing.Literal[\"system\", \"user\", \"assistant\", \"tool\"]]: ...\n    @role.setter\n    def role(self, value: typing.Optional[typing.Literal[\"system\", \"user\", \"assistant\", \"tool\"]]) -&gt; None: ...\n    @property\n    def contents(self) -&gt; builtins.list[PartDelta]: ...\n    @contents.setter\n    def contents(self, value: builtins.list[PartDelta]) -&gt; None: ...\n    @property\n    def id(self) -&gt; typing.Optional[builtins.str]: ...\n    @id.setter\n    def id(self, value: typing.Optional[builtins.str]) -&gt; None: ...\n    @property\n    def thinking(self) -&gt; typing.Optional[builtins.str]: ...\n    @thinking.setter\n    def thinking(self, value: typing.Optional[builtins.str]) -&gt; None: ...\n    @property\n    def tool_calls(self) -&gt; builtins.list[PartDelta]: ...\n    @tool_calls.setter\n    def tool_calls(self, value: builtins.list[PartDelta]) -&gt; None: ...\n    @property\n    def signature(self) -&gt; typing.Optional[builtins.str]: ...\n    @signature.setter\n    def signature(self, value: typing.Optional[builtins.str]) -&gt; None: ...\n    def __new__(cls, role: typing.Optional[typing.Literal[\"system\", \"user\", \"assistant\", \"tool\"]] = None, contents: typing.Optional[typing.Sequence[PartDelta]] = None, id: typing.Optional[builtins.str] = None, thinking: typing.Optional[builtins.str] = None, tool_calls: typing.Optional[typing.Sequence[PartDelta]] = None, signature: typing.Optional[builtins.str] = None) -&gt; MessageDelta: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    def __add__(self, other: MessageDelta) -&gt; MessageDelta: ...\n    def to_message(self) -&gt; Message: ...\n</code></pre>"},{"location":"#ailoy.MessageDelta.contents","title":"contents  <code>property</code> <code>writable</code>","text":"<pre><code>contents: list[PartDelta]\n</code></pre>"},{"location":"#ailoy.MessageDelta.id","title":"id  <code>property</code> <code>writable</code>","text":"<pre><code>id: Optional[str]\n</code></pre>"},{"location":"#ailoy.MessageDelta.role","title":"role  <code>property</code> <code>writable</code>","text":"<pre><code>role: Optional[\n    Literal[\"system\", \"user\", \"assistant\", \"tool\"]\n]\n</code></pre>"},{"location":"#ailoy.MessageDelta.signature","title":"signature  <code>property</code> <code>writable</code>","text":"<pre><code>signature: Optional[str]\n</code></pre>"},{"location":"#ailoy.MessageDelta.thinking","title":"thinking  <code>property</code> <code>writable</code>","text":"<pre><code>thinking: Optional[str]\n</code></pre>"},{"location":"#ailoy.MessageDelta.tool_calls","title":"tool_calls  <code>property</code> <code>writable</code>","text":"<pre><code>tool_calls: list[PartDelta]\n</code></pre>"},{"location":"#ailoy.MessageDelta.__add__","title":"__add__","text":"<pre><code>__add__(other: MessageDelta) -&gt; MessageDelta\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __add__(self, other: MessageDelta) -&gt; MessageDelta: ...\n</code></pre>"},{"location":"#ailoy.MessageDelta.to_message","title":"to_message","text":"<pre><code>to_message() -&gt; Message\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def to_message(self) -&gt; Message: ...\n</code></pre>"},{"location":"#ailoy.MessageOutput","title":"MessageOutput","text":"<p>A container for a streamed message delta and its termination signal.</p> <p>During streaming, <code>delta</code> carries the incremental payload; once a terminal condition is reached, <code>finish_reason</code> may be populated to explain why.</p>"},{"location":"#ailoy.MessageOutput--examples","title":"Examples","text":"<pre><code>let mut out = MessageOutput::new();\nout.delta = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: \"Hi\".into() }]);\nassert!(out.finish_reason.is_none());\n</code></pre>"},{"location":"#ailoy.MessageOutput--lifecycle","title":"Lifecycle","text":"<ul> <li>While streaming: <code>finish_reason</code> is typically <code>None</code>.</li> <li>On completion: <code>finish_reason</code> is set; callers can then <code>finish()</code> the delta to obtain a concrete [<code>Message</code>].</li> </ul> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass MessageOutput:\n    r\"\"\"\n    A container for a streamed message delta and its termination signal.\n\n    During streaming, `delta` carries the incremental payload; once a terminal\n    condition is reached, `finish_reason` may be populated to explain why.\n\n    # Examples\n    ```rust\n    let mut out = MessageOutput::new();\n    out.delta = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: \"Hi\".into() }]);\n    assert!(out.finish_reason.is_none());\n    ```\n\n    # Lifecycle\n    - While streaming: `finish_reason` is typically `None`.\n    - On completion: `finish_reason` is set; callers can then `finish()` the delta to obtain a concrete [`Message`].\n    \"\"\"\n    @property\n    def delta(self) -&gt; MessageDelta: ...\n    @delta.setter\n    def delta(self, value: MessageDelta) -&gt; None: ...\n    @property\n    def finish_reason(self) -&gt; typing.Optional[FinishReason]: ...\n    @finish_reason.setter\n    def finish_reason(self, value: typing.Optional[FinishReason]) -&gt; None: ...\n    def __repr__(self) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.MessageOutput.delta","title":"delta  <code>property</code> <code>writable</code>","text":"<pre><code>delta: MessageDelta\n</code></pre>"},{"location":"#ailoy.MessageOutput.finish_reason","title":"finish_reason  <code>property</code> <code>writable</code>","text":"<pre><code>finish_reason: Optional[FinishReason]\n</code></pre>"},{"location":"#ailoy.Part","title":"Part","text":"<p>Represents a semantically meaningful content unit exchanged between the model and the user.</p> <p>Conceptually, each <code>Part</code> encapsulates a piece of data that contributes to a chat message \u2014 such as text, a function invocation, or an image.  </p> <p>For example, a single message consisting of a sequence like <code>(text..., image, text...)</code> is represented as a <code>Message</code> containing an array of three <code>Part</code> elements.</p> <p>Note that a <code>Part</code> does not carry \"intent\", such as \"reasoning\" or \"tool call\". These higher-level semantics are determined by the context of a [<code>Message</code>].</p>"},{"location":"#ailoy.Part--example","title":"Example","text":""},{"location":"#ailoy.Part--rust","title":"Rust","text":"<pre><code>let part = Part::text(\"Hello, world!\");\nassert!(part.is_text());\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>class Part:\n    r\"\"\"\n    Represents a semantically meaningful content unit exchanged between the model and the user.\n\n    Conceptually, each `Part` encapsulates a piece of **data** that contributes\n    to a chat message \u2014 such as text, a function invocation, or an image.  \n\n    For example, a single message consisting of a sequence like  \n    `(text..., image, text...)` is represented as a `Message` containing\n    an array of three `Part` elements.\n\n    Note that a `Part` does **not** carry \"intent\", such as \"reasoning\" or \"tool call\".\n    These higher-level semantics are determined by the context of a [`Message`].\n\n    # Example\n\n    ## Rust\n    ```rust\n    let part = Part::text(\"Hello, world!\");\n    assert!(part.is_text());\n    ```\n    \"\"\"\n    @property\n    def part_type(self) -&gt; builtins.str: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    @classmethod\n    def image_from_bytes(cls, data: bytes) -&gt; Part: ...\n    @classmethod\n    def image_from_base64(cls, data: builtins.str) -&gt; Part: ...\n    @classmethod\n    def image_from_url(cls, url: builtins.str) -&gt; Part: ...\n    @typing.final\n    class Text(Part):\n        r\"\"\"\n        Plain utf-8 encoded text.\n        \"\"\"\n        __match_args__ = (\"text\",)\n        @property\n        def text(self) -&gt; builtins.str: ...\n        def __new__(cls, text: builtins.str) -&gt; Part.Text: ...\n\n    @typing.final\n    class Function(Part):\n        r\"\"\"\n        Represents a structured function call to an external tool.\n\n        Many language models (LLMs) use a **function calling** mechanism to extend their capabilities.\n        When an LLM decides to use external *tools*, it produces a structured output called a `function`.\n        A function conventionally consists of two fields: a `name`, and an `arguments` field formatted as JSON.\n        This is conceptually similar to making an HTTP POST request, where the request body carries a single JSON object.\n\n        This struct models that convention, representing a function invocation request\n        from an LLM to an external tool or API.\n\n        # Examples\n        ```rust\n        let f = PartFunction {\n            name: \"translate\".to_string(),\n            arguments: Value::from_json(r#\"{\"source\": \"hello\", \"lang\": \"cn\"}\"#).unwrap(),\n        };\n        ```\n        \"\"\"\n        __match_args__ = (\"id\", \"function\",)\n        @property\n        def id(self) -&gt; typing.Optional[builtins.str]: ...\n        @property\n        def function(self) -&gt; PartFunction: ...\n        def __new__(cls, id: typing.Optional[builtins.str], function: PartFunction) -&gt; Part.Function: ...\n\n    @typing.final\n    class Value(Part):\n        r\"\"\"\n        Holds a structured data value, typically considered as a JSON structure.\n        \"\"\"\n        __match_args__ = (\"value\",)\n        @property\n        def value(self) -&gt; typing.Any: ...\n        def __new__(cls, value: typing.Any) -&gt; Part.Value: ...\n\n    @typing.final\n    class Image(Part):\n        r\"\"\"\n        Contains an image payload or reference used within a message part.\n        The image may be provided as raw binary data or an encoded format (e.g., PNG, JPEG),\n        or as a reference via a URL. Optional metadata can be included alongside the image.\n        \"\"\"\n        __match_args__ = (\"image\",)\n        @property\n        def image(self) -&gt; PartImage: ...\n        def __new__(cls, image: PartImage) -&gt; Part.Image: ...\n</code></pre>"},{"location":"#ailoy.Part.part_type","title":"part_type  <code>property</code>","text":"<pre><code>part_type: str\n</code></pre>"},{"location":"#ailoy.Part.Function","title":"Function","text":"<p>               Bases: <code>Part</code></p> <p>Represents a structured function call to an external tool.</p> <p>Many language models (LLMs) use a function calling mechanism to extend their capabilities. When an LLM decides to use external tools, it produces a structured output called a <code>function</code>. A function conventionally consists of two fields: a <code>name</code>, and an <code>arguments</code> field formatted as JSON. This is conceptually similar to making an HTTP POST request, where the request body carries a single JSON object.</p> <p>This struct models that convention, representing a function invocation request from an LLM to an external tool or API.</p>"},{"location":"#ailoy.Part.Function--examples","title":"Examples","text":"<pre><code>let f = PartFunction {\n    name: \"translate\".to_string(),\n    arguments: Value::from_json(r#\"{\"source\": \"hello\", \"lang\": \"cn\"}\"#).unwrap(),\n};\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Function(Part):\n    r\"\"\"\n    Represents a structured function call to an external tool.\n\n    Many language models (LLMs) use a **function calling** mechanism to extend their capabilities.\n    When an LLM decides to use external *tools*, it produces a structured output called a `function`.\n    A function conventionally consists of two fields: a `name`, and an `arguments` field formatted as JSON.\n    This is conceptually similar to making an HTTP POST request, where the request body carries a single JSON object.\n\n    This struct models that convention, representing a function invocation request\n    from an LLM to an external tool or API.\n\n    # Examples\n    ```rust\n    let f = PartFunction {\n        name: \"translate\".to_string(),\n        arguments: Value::from_json(r#\"{\"source\": \"hello\", \"lang\": \"cn\"}\"#).unwrap(),\n    };\n    ```\n    \"\"\"\n    __match_args__ = (\"id\", \"function\",)\n    @property\n    def id(self) -&gt; typing.Optional[builtins.str]: ...\n    @property\n    def function(self) -&gt; PartFunction: ...\n    def __new__(cls, id: typing.Optional[builtins.str], function: PartFunction) -&gt; Part.Function: ...\n</code></pre>"},{"location":"#ailoy.Part.Function.function","title":"function  <code>property</code>","text":"<pre><code>function: PartFunction\n</code></pre>"},{"location":"#ailoy.Part.Function.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[str]\n</code></pre>"},{"location":"#ailoy.Part.Image","title":"Image","text":"<p>               Bases: <code>Part</code></p> <p>Contains an image payload or reference used within a message part. The image may be provided as raw binary data or an encoded format (e.g., PNG, JPEG), or as a reference via a URL. Optional metadata can be included alongside the image.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Image(Part):\n    r\"\"\"\n    Contains an image payload or reference used within a message part.\n    The image may be provided as raw binary data or an encoded format (e.g., PNG, JPEG),\n    or as a reference via a URL. Optional metadata can be included alongside the image.\n    \"\"\"\n    __match_args__ = (\"image\",)\n    @property\n    def image(self) -&gt; PartImage: ...\n    def __new__(cls, image: PartImage) -&gt; Part.Image: ...\n</code></pre>"},{"location":"#ailoy.Part.Image.image","title":"image  <code>property</code>","text":"<pre><code>image: PartImage\n</code></pre>"},{"location":"#ailoy.Part.Text","title":"Text","text":"<p>               Bases: <code>Part</code></p> <p>Plain utf-8 encoded text.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Text(Part):\n    r\"\"\"\n    Plain utf-8 encoded text.\n    \"\"\"\n    __match_args__ = (\"text\",)\n    @property\n    def text(self) -&gt; builtins.str: ...\n    def __new__(cls, text: builtins.str) -&gt; Part.Text: ...\n</code></pre>"},{"location":"#ailoy.Part.Text.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre>"},{"location":"#ailoy.Part.Value","title":"Value","text":"<p>               Bases: <code>Part</code></p> <p>Holds a structured data value, typically considered as a JSON structure.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Value(Part):\n    r\"\"\"\n    Holds a structured data value, typically considered as a JSON structure.\n    \"\"\"\n    __match_args__ = (\"value\",)\n    @property\n    def value(self) -&gt; typing.Any: ...\n    def __new__(cls, value: typing.Any) -&gt; Part.Value: ...\n</code></pre>"},{"location":"#ailoy.Part.Value.value","title":"value  <code>property</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"#ailoy.Part.image_from_base64","title":"image_from_base64  <code>classmethod</code>","text":"<pre><code>image_from_base64(data: str) -&gt; Part\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef image_from_base64(cls, data: builtins.str) -&gt; Part: ...\n</code></pre>"},{"location":"#ailoy.Part.image_from_bytes","title":"image_from_bytes  <code>classmethod</code>","text":"<pre><code>image_from_bytes(data: bytes) -&gt; Part\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef image_from_bytes(cls, data: bytes) -&gt; Part: ...\n</code></pre>"},{"location":"#ailoy.Part.image_from_url","title":"image_from_url  <code>classmethod</code>","text":"<pre><code>image_from_url(url: str) -&gt; Part\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef image_from_url(cls, url: builtins.str) -&gt; Part: ...\n</code></pre>"},{"location":"#ailoy.PartDelta","title":"PartDelta","text":"<p>Represents a partial or incremental update (delta) of a [<code>Part</code>].</p> <p>This type enables composable, streaming updates to message parts. For example, text may be produced token-by-token, or a function call may be emitted gradually as its arguments stream in.</p>"},{"location":"#ailoy.PartDelta--example","title":"Example","text":""},{"location":"#ailoy.PartDelta--rust","title":"Rust","text":"<pre><code>let d1 = PartDelta::Text { text: \"Hel\".into() };\nlet d2 = PartDelta::Text { text: \"lo\".into() };\nlet merged = d1.accumulate(d2).unwrap();\nassert_eq!(merged.to_text().unwrap(), \"Hello\");\n</code></pre>"},{"location":"#ailoy.PartDelta--error-handling","title":"Error Handling","text":"<p>Accumulation or finalization may return an error if incompatible deltas (e.g. mismatched function IDs) are combined or invalid JSON arguments are given.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>class PartDelta:\n    r\"\"\"\n    Represents a partial or incremental update (delta) of a [`Part`].\n\n    This type enables composable, streaming updates to message parts.\n    For example, text may be produced token-by-token, or a function call\n    may be emitted gradually as its arguments stream in.\n\n    # Example\n\n    ## Rust\n    ```rust\n    let d1 = PartDelta::Text { text: \"Hel\".into() };\n    let d2 = PartDelta::Text { text: \"lo\".into() };\n    let merged = d1.accumulate(d2).unwrap();\n    assert_eq!(merged.to_text().unwrap(), \"Hello\");\n    ```\n\n    # Error Handling\n    Accumulation or finalization may return an error if incompatible deltas\n    (e.g. mismatched function IDs) are combined or invalid JSON arguments are given.\n    \"\"\"\n    @property\n    def part_type(self) -&gt; builtins.str: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    @typing.final\n    class Text(PartDelta):\n        r\"\"\"\n        Incremental text fragment.\n        \"\"\"\n        __match_args__ = (\"text\",)\n        @property\n        def text(self) -&gt; builtins.str: ...\n        def __new__(cls, text: builtins.str) -&gt; PartDelta.Text: ...\n\n    @typing.final\n    class Function(PartDelta):\n        r\"\"\"\n        Incremental function call fragment.\n        \"\"\"\n        __match_args__ = (\"id\", \"function\",)\n        @property\n        def id(self) -&gt; typing.Optional[builtins.str]: ...\n        @property\n        def function(self) -&gt; PartDeltaFunction: ...\n        def __new__(cls, id: typing.Optional[builtins.str], function: PartDeltaFunction) -&gt; PartDelta.Function: ...\n\n    @typing.final\n    class Value(PartDelta):\n        r\"\"\"\n        JSON-like value update.\n        \"\"\"\n        __match_args__ = (\"value\",)\n        @property\n        def value(self) -&gt; typing.Any: ...\n        def __new__(cls, value: typing.Any) -&gt; PartDelta.Value: ...\n\n    @typing.final\n    class Null(PartDelta):\n        r\"\"\"\n        Placeholder representing no data yet.\n        \"\"\"\n        __match_args__ = ()\n        def __new__(cls) -&gt; PartDelta.Null: ...\n</code></pre>"},{"location":"#ailoy.PartDelta.part_type","title":"part_type  <code>property</code>","text":"<pre><code>part_type: str\n</code></pre>"},{"location":"#ailoy.PartDelta.Function","title":"Function","text":"<p>               Bases: <code>PartDelta</code></p> <p>Incremental function call fragment.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Function(PartDelta):\n    r\"\"\"\n    Incremental function call fragment.\n    \"\"\"\n    __match_args__ = (\"id\", \"function\",)\n    @property\n    def id(self) -&gt; typing.Optional[builtins.str]: ...\n    @property\n    def function(self) -&gt; PartDeltaFunction: ...\n    def __new__(cls, id: typing.Optional[builtins.str], function: PartDeltaFunction) -&gt; PartDelta.Function: ...\n</code></pre>"},{"location":"#ailoy.PartDelta.Function.function","title":"function  <code>property</code>","text":"<pre><code>function: PartDeltaFunction\n</code></pre>"},{"location":"#ailoy.PartDelta.Function.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[str]\n</code></pre>"},{"location":"#ailoy.PartDelta.Null","title":"Null","text":"<p>               Bases: <code>PartDelta</code></p> <p>Placeholder representing no data yet.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Null(PartDelta):\n    r\"\"\"\n    Placeholder representing no data yet.\n    \"\"\"\n    __match_args__ = ()\n    def __new__(cls) -&gt; PartDelta.Null: ...\n</code></pre>"},{"location":"#ailoy.PartDelta.Text","title":"Text","text":"<p>               Bases: <code>PartDelta</code></p> <p>Incremental text fragment.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Text(PartDelta):\n    r\"\"\"\n    Incremental text fragment.\n    \"\"\"\n    __match_args__ = (\"text\",)\n    @property\n    def text(self) -&gt; builtins.str: ...\n    def __new__(cls, text: builtins.str) -&gt; PartDelta.Text: ...\n</code></pre>"},{"location":"#ailoy.PartDelta.Text.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre>"},{"location":"#ailoy.PartDelta.Value","title":"Value","text":"<p>               Bases: <code>PartDelta</code></p> <p>JSON-like value update.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Value(PartDelta):\n    r\"\"\"\n    JSON-like value update.\n    \"\"\"\n    __match_args__ = (\"value\",)\n    @property\n    def value(self) -&gt; typing.Any: ...\n    def __new__(cls, value: typing.Any) -&gt; PartDelta.Value: ...\n</code></pre>"},{"location":"#ailoy.PartDelta.Value.value","title":"value  <code>property</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction","title":"PartDeltaFunction","text":"<p>Represents an incremental update (delta) of a function part.</p> <p>This type is used during streaming or partial message generation, when function calls are being streamed as text chunks or partial JSON fragments.</p>"},{"location":"#ailoy.PartDeltaFunction--variants","title":"Variants","text":"<ul> <li><code>Verbatim(String)</code> \u2014 Raw text content, typically a partial JSON fragment.</li> <li><code>WithStringArgs { name, arguments }</code> \u2014 Function name and its serialized arguments as strings.</li> <li><code>WithParsedArgs { name, arguments }</code> \u2014 Function name and parsed arguments as a <code>Value</code>.</li> </ul>"},{"location":"#ailoy.PartDeltaFunction--use-case","title":"Use Case","text":"<p>When the model streams out a function call response (e.g., <code>\"function_call\":{\"name\":...}</code>), the incremental deltas can be accumulated until the full function payload is formed.</p>"},{"location":"#ailoy.PartDeltaFunction--example","title":"Example","text":"<pre><code>let delta = PartDeltaFunction::WithStringArgs {\n    name: \"translate\".into(),\n    arguments: r#\"{\"text\":\"hi\"}\"#.into(),\n};\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>class PartDeltaFunction:\n    r\"\"\"\n    Represents an incremental update (delta) of a function part.\n\n    This type is used during streaming or partial message generation, when function calls are being streamed as text chunks or partial JSON fragments.\n\n    # Variants\n    * `Verbatim(String)` \u2014 Raw text content, typically a partial JSON fragment.\n    * `WithStringArgs { name, arguments }` \u2014 Function name and its serialized arguments as strings.\n    * `WithParsedArgs { name, arguments }` \u2014 Function name and parsed arguments as a `Value`.\n\n    # Use Case\n    When the model streams out a function call response (e.g., `\"function_call\":{\"name\":...}`),\n    the incremental deltas can be accumulated until the full function payload is formed.\n\n    # Example\n    ```rust\n    let delta = PartDeltaFunction::WithStringArgs {\n        name: \"translate\".into(),\n        arguments: r#\"{\"text\":\"hi\"}\"#.into(),\n    };\n    ```\n    \"\"\"\n    @typing.final\n    class Verbatim(PartDeltaFunction):\n        __match_args__ = (\"text\",)\n        @property\n        def text(self) -&gt; builtins.str: ...\n        def __new__(cls, text: builtins.str) -&gt; PartDeltaFunction.Verbatim: ...\n\n    @typing.final\n    class WithStringArgs(PartDeltaFunction):\n        __match_args__ = (\"name\", \"arguments\",)\n        @property\n        def name(self) -&gt; builtins.str: ...\n        @property\n        def arguments(self) -&gt; builtins.str: ...\n        def __new__(cls, name: builtins.str, arguments: builtins.str) -&gt; PartDeltaFunction.WithStringArgs: ...\n\n    @typing.final\n    class WithParsedArgs(PartDeltaFunction):\n        __match_args__ = (\"name\", \"arguments\",)\n        @property\n        def name(self) -&gt; builtins.str: ...\n        @property\n        def arguments(self) -&gt; typing.Any: ...\n        def __new__(cls, name: builtins.str, arguments: typing.Any) -&gt; PartDeltaFunction.WithParsedArgs: ...\n\n    ...\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.Verbatim","title":"Verbatim","text":"<p>               Bases: <code>PartDeltaFunction</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Verbatim(PartDeltaFunction):\n    __match_args__ = (\"text\",)\n    @property\n    def text(self) -&gt; builtins.str: ...\n    def __new__(cls, text: builtins.str) -&gt; PartDeltaFunction.Verbatim: ...\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.Verbatim.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithParsedArgs","title":"WithParsedArgs","text":"<p>               Bases: <code>PartDeltaFunction</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass WithParsedArgs(PartDeltaFunction):\n    __match_args__ = (\"name\", \"arguments\",)\n    @property\n    def name(self) -&gt; builtins.str: ...\n    @property\n    def arguments(self) -&gt; typing.Any: ...\n    def __new__(cls, name: builtins.str, arguments: typing.Any) -&gt; PartDeltaFunction.WithParsedArgs: ...\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithParsedArgs.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: Any\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithParsedArgs.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithStringArgs","title":"WithStringArgs","text":"<p>               Bases: <code>PartDeltaFunction</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass WithStringArgs(PartDeltaFunction):\n    __match_args__ = (\"name\", \"arguments\",)\n    @property\n    def name(self) -&gt; builtins.str: ...\n    @property\n    def arguments(self) -&gt; builtins.str: ...\n    def __new__(cls, name: builtins.str, arguments: builtins.str) -&gt; PartDeltaFunction.WithStringArgs: ...\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithStringArgs.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: str\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithStringArgs.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.PartFunction","title":"PartFunction","text":"<p>Represents a function call contained within a message part.</p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass PartFunction:\n    r\"\"\"\n    Represents a function call contained within a message part.\n    \"\"\"\n    @property\n    def name(self) -&gt; builtins.str: ...\n    @property\n    def arguments(self) -&gt; dict[str, typing.Any]: ...\n    def __eq__(self, other: builtins.object) -&gt; builtins.bool: ...\n</code></pre>"},{"location":"#ailoy.PartFunction.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: dict[str, Any]\n</code></pre>"},{"location":"#ailoy.PartFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.PartImage","title":"PartImage","text":"<p>Represents the image data contained in a [<code>Part</code>].</p> <p><code>PartImage</code> provides structured access to image data. Currently, it only implments \"binary\" types.</p>"},{"location":"#ailoy.PartImage--example","title":"Example","text":"<pre><code>let part = Part::image_binary(640, 480, \"rgb\", (0..640*480*3).map(|i| (i % 255) as u8)).unwrap();\n\nif let Some(img) = part.as_image() {\n    assert_eq!(img.height(), 640);\n    assert_eq!(img.width(), 480);\n}\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>class PartImage:\n    r\"\"\"\n    Represents the image data contained in a [`Part`].\n\n    `PartImage` provides structured access to image data.\n    Currently, it only implments \"binary\" types.\n\n    # Example\n    ```rust\n    let part = Part::image_binary(640, 480, \"rgb\", (0..640*480*3).map(|i| (i % 255) as u8)).unwrap();\n\n    if let Some(img) = part.as_image() {\n        assert_eq!(img.height(), 640);\n        assert_eq!(img.width(), 480);\n    }\n    ```\n    \"\"\"\n    @typing.final\n    class Binary(PartImage):\n        __match_args__ = (\"height\", \"width\", \"colorspace\", \"data\",)\n        @property\n        def height(self) -&gt; builtins.int: ...\n        @property\n        def width(self) -&gt; builtins.int: ...\n        @property\n        def colorspace(self) -&gt; typing.Literal[\"grayscale\", \"rgb\", \"rgba\"]: ...\n        @property\n        def data(self) -&gt; typing.Any: ...\n        def __new__(cls, height: builtins.int, width: builtins.int, colorspace: typing.Literal[\"grayscale\", \"rgb\", \"rgba\"], data: typing.Any) -&gt; PartImage.Binary: ...\n\n    @typing.final\n    class Url(PartImage):\n        __match_args__ = (\"url\",)\n        @property\n        def url(self) -&gt; builtins.str: ...\n        def __new__(cls, url: builtins.str) -&gt; PartImage.Url: ...\n\n    ...\n</code></pre>"},{"location":"#ailoy.PartImage.Binary","title":"Binary","text":"<p>               Bases: <code>PartImage</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Binary(PartImage):\n    __match_args__ = (\"height\", \"width\", \"colorspace\", \"data\",)\n    @property\n    def height(self) -&gt; builtins.int: ...\n    @property\n    def width(self) -&gt; builtins.int: ...\n    @property\n    def colorspace(self) -&gt; typing.Literal[\"grayscale\", \"rgb\", \"rgba\"]: ...\n    @property\n    def data(self) -&gt; typing.Any: ...\n    def __new__(cls, height: builtins.int, width: builtins.int, colorspace: typing.Literal[\"grayscale\", \"rgb\", \"rgba\"], data: typing.Any) -&gt; PartImage.Binary: ...\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.colorspace","title":"colorspace  <code>property</code>","text":"<pre><code>colorspace: Literal['grayscale', 'rgb', 'rgba']\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.data","title":"data  <code>property</code>","text":"<pre><code>data: Any\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre>"},{"location":"#ailoy.PartImage.Url","title":"Url","text":"<p>               Bases: <code>PartImage</code></p> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass Url(PartImage):\n    __match_args__ = (\"url\",)\n    @property\n    def url(self) -&gt; builtins.str: ...\n    def __new__(cls, url: builtins.str) -&gt; PartImage.Url: ...\n</code></pre>"},{"location":"#ailoy.PartImage.Url.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"#ailoy.Tool","title":"Tool","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>class Tool:\n    @classmethod\n    def new_builtin(cls, kind: typing.Literal[\"terminal\"]) -&gt; Tool: ...\n    @classmethod\n    def new_py_function(cls, desc: ToolDesc, func: typing.Any) -&gt; Tool: ...\n    def __repr__(self) -&gt; builtins.str: ...\n    def get_description(self) -&gt; ToolDesc: ...\n    def __call__(self, **kwargs: typing.Any) -&gt; typing.Awaitable[typing.Any]: ...\n    def call(self, **kwargs: typing.Any) -&gt; typing.Awaitable[typing.Any]: ...\n    def call_sync(self, **kwargs: typing.Any) -&gt; typing.Any: ...\n</code></pre>"},{"location":"#ailoy.Tool.__call__","title":"__call__","text":"<pre><code>__call__(**kwargs: Any) -&gt; Awaitable[Any]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def __call__(self, **kwargs: typing.Any) -&gt; typing.Awaitable[typing.Any]: ...\n</code></pre>"},{"location":"#ailoy.Tool.call","title":"call","text":"<pre><code>call(**kwargs: Any) -&gt; Awaitable[Any]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def call(self, **kwargs: typing.Any) -&gt; typing.Awaitable[typing.Any]: ...\n</code></pre>"},{"location":"#ailoy.Tool.call_sync","title":"call_sync","text":"<pre><code>call_sync(**kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def call_sync(self, **kwargs: typing.Any) -&gt; typing.Any: ...\n</code></pre>"},{"location":"#ailoy.Tool.get_description","title":"get_description","text":"<pre><code>get_description() -&gt; ToolDesc\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def get_description(self) -&gt; ToolDesc: ...\n</code></pre>"},{"location":"#ailoy.Tool.new_builtin","title":"new_builtin  <code>classmethod</code>","text":"<pre><code>new_builtin(kind: Literal['terminal']) -&gt; Tool\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_builtin(cls, kind: typing.Literal[\"terminal\"]) -&gt; Tool: ...\n</code></pre>"},{"location":"#ailoy.Tool.new_py_function","title":"new_py_function  <code>classmethod</code>","text":"<pre><code>new_py_function(desc: ToolDesc, func: Any) -&gt; Tool\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_py_function(cls, desc: ToolDesc, func: typing.Any) -&gt; Tool: ...\n</code></pre>"},{"location":"#ailoy.ToolDesc","title":"ToolDesc","text":"<p>Describes a tool (or function) that a language model can invoke.</p> <p><code>ToolDesc</code> defines the schema, behavior, and input/output specification of a callable external function, allowing an LLM to understand how to use it.</p> <p>The primary role of this struct is to describe to the LLM what a tool does, how it can be invoked, and what input (<code>parameters</code>) and output (<code>returns</code>) schemas it expects.</p> <p>The format follows the same schema conventions used by Hugging Face\u2019s <code>transformers</code> library, as well as APIs such as OpenAI and Anthropic. The <code>parameters</code> and <code>returns</code> fields are typically defined using JSON Schema.</p> <p>We provide a builder [<code>ToolDescBuilder</code>] helper for convenient and fluent construction. Please refer to [<code>ToolDescBuilder</code>].</p>"},{"location":"#ailoy.ToolDesc--example","title":"Example","text":"<pre><code>use crate::value::{ToolDescBuilder, to_value};\n\nlet desc = ToolDescBuilder::new(\"temperature\")\n    .description(\"Get the current temperature for a given city\")\n    .parameters(to_value!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"The city name\"\n            },\n            \"unit\": {\n                \"type\": \"string\",\n                \"description\": \"Temperature unit (default: Celsius)\",\n                \"enum\": [\"Celsius\", \"Fahrenheit\"]\n            }\n        },\n        \"required\": [\"location\"]\n    }))\n    .returns(to_value!({\n        \"type\": \"number\"\n    }))\n    .build();\n\nassert_eq!(desc.name, \"temperature\");\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass ToolDesc:\n    r\"\"\"\n    Describes a **tool** (or function) that a language model can invoke.\n\n    `ToolDesc` defines the schema, behavior, and input/output specification of a callable\n    external function, allowing an LLM to understand how to use it.\n\n    The primary role of this struct is to describe to the LLM what a *tool* does,\n    how it can be invoked, and what input (`parameters`) and output (`returns`) schemas it expects.\n\n    The format follows the same **schema conventions** used by Hugging Face\u2019s\n    `transformers` library, as well as APIs such as *OpenAI* and *Anthropic*.\n    The `parameters` and `returns` fields are typically defined using **JSON Schema**.\n\n    We provide a builder [`ToolDescBuilder`] helper for convenient and fluent construction.\n    Please refer to [`ToolDescBuilder`].\n\n    # Example\n    ```rust\n    use crate::value::{ToolDescBuilder, to_value};\n\n    let desc = ToolDescBuilder::new(\"temperature\")\n        .description(\"Get the current temperature for a given city\")\n        .parameters(to_value!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"location\": {\n                    \"type\": \"string\",\n                    \"description\": \"The city name\"\n                },\n                \"unit\": {\n                    \"type\": \"string\",\n                    \"description\": \"Temperature unit (default: Celsius)\",\n                    \"enum\": [\"Celsius\", \"Fahrenheit\"]\n                }\n            },\n            \"required\": [\"location\"]\n        }))\n        .returns(to_value!({\n            \"type\": \"number\"\n        }))\n        .build();\n\n    assert_eq!(desc.name, \"temperature\");\n    ```\n    \"\"\"\n    @property\n    def name(self) -&gt; builtins.str: ...\n    @property\n    def description(self) -&gt; typing.Optional[builtins.str]: ...\n    @property\n    def parameters(self) -&gt; dict: ...\n    @property\n    def returns(self) -&gt; typing.Optional[dict]: ...\n    def __new__(cls, name: builtins.str, description: typing.Optional[builtins.str], parameters: dict, *, returns: typing.Optional[dict] = None) -&gt; ToolDesc: ...\n    def __repr__(self) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.ToolDesc.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"#ailoy.ToolDesc.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.ToolDesc.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: dict\n</code></pre>"},{"location":"#ailoy.ToolDesc.returns","title":"returns  <code>property</code>","text":"<pre><code>returns: Optional[dict]\n</code></pre>"},{"location":"#ailoy.VectorStore","title":"VectorStore","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass VectorStore:\n    @classmethod\n    def new_faiss(cls, dim: builtins.int) -&gt; VectorStore: ...\n    @classmethod\n    def new_chroma(cls, url: builtins.str, collection_name: typing.Optional[builtins.str]) -&gt; VectorStore: ...\n    def add_vector(self, input: VectorStoreAddInput) -&gt; builtins.str: ...\n    def add_vectors(self, inputs: typing.Sequence[VectorStoreAddInput]) -&gt; builtins.list[builtins.str]: ...\n    def get_by_id(self, id: builtins.str) -&gt; typing.Optional[VectorStoreGetResult]: ...\n    def get_by_ids(self, ids: typing.Sequence[builtins.str]) -&gt; builtins.list[VectorStoreGetResult]: ...\n    def retrieve(self, query_embedding: builtins.list[float], top_k: builtins.int) -&gt; builtins.list[VectorStoreRetrieveResult]: ...\n    def batch_retrieve(self, query_embeddings: typing.Sequence[builtins.list[float]], top_k: builtins.int) -&gt; builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...\n    def remove_vector(self, id: builtins.str) -&gt; None: ...\n    def remove_vectors(self, ids: typing.Sequence[builtins.str]) -&gt; None: ...\n    def clear(self) -&gt; None: ...\n    def count(self) -&gt; builtins.int: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.add_vector","title":"add_vector","text":"<pre><code>add_vector(input: VectorStoreAddInput) -&gt; str\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def add_vector(self, input: VectorStoreAddInput) -&gt; builtins.str: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.add_vectors","title":"add_vectors","text":"<pre><code>add_vectors(\n    inputs: Sequence[VectorStoreAddInput],\n) -&gt; list[str]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def add_vectors(self, inputs: typing.Sequence[VectorStoreAddInput]) -&gt; builtins.list[builtins.str]: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.batch_retrieve","title":"batch_retrieve","text":"<pre><code>batch_retrieve(\n    query_embeddings: Sequence[list[float]], top_k: int\n) -&gt; list[list[VectorStoreRetrieveResult]]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def batch_retrieve(self, query_embeddings: typing.Sequence[builtins.list[float]], top_k: builtins.int) -&gt; builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def clear(self) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def count(self) -&gt; builtins.int: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(id: str) -&gt; Optional[VectorStoreGetResult]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def get_by_id(self, id: builtins.str) -&gt; typing.Optional[VectorStoreGetResult]: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    ids: Sequence[str],\n) -&gt; list[VectorStoreGetResult]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def get_by_ids(self, ids: typing.Sequence[builtins.str]) -&gt; builtins.list[VectorStoreGetResult]: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.new_chroma","title":"new_chroma  <code>classmethod</code>","text":"<pre><code>new_chroma(\n    url: str, collection_name: Optional[str]\n) -&gt; VectorStore\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_chroma(cls, url: builtins.str, collection_name: typing.Optional[builtins.str]) -&gt; VectorStore: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.new_faiss","title":"new_faiss  <code>classmethod</code>","text":"<pre><code>new_faiss(dim: int) -&gt; VectorStore\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>@classmethod\ndef new_faiss(cls, dim: builtins.int) -&gt; VectorStore: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.remove_vector","title":"remove_vector","text":"<pre><code>remove_vector(id: str) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def remove_vector(self, id: builtins.str) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.remove_vectors","title":"remove_vectors","text":"<pre><code>remove_vectors(ids: Sequence[str]) -&gt; None\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def remove_vectors(self, ids: typing.Sequence[builtins.str]) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.VectorStore.retrieve","title":"retrieve","text":"<pre><code>retrieve(\n    query_embedding: list[float], top_k: int\n) -&gt; list[VectorStoreRetrieveResult]\n</code></pre> Source code in <code>ailoy/_core.pyi</code> <pre><code>def retrieve(self, query_embedding: builtins.list[float], top_k: builtins.int) -&gt; builtins.list[VectorStoreRetrieveResult]: ...\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput","title":"VectorStoreAddInput","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass VectorStoreAddInput:\n    @property\n    def embedding(self) -&gt; builtins.list[float]: ...\n    @embedding.setter\n    def embedding(self, value: builtins.list[float]) -&gt; None: ...\n    @property\n    def document(self) -&gt; builtins.str: ...\n    @document.setter\n    def document(self, value: builtins.str) -&gt; None: ...\n    @property\n    def metadata(self) -&gt; typing.Optional[builtins.dict[builtins.str, typing.Any]]: ...\n    @metadata.setter\n    def metadata(self, value: typing.Optional[builtins.dict[builtins.str, typing.Any]]) -&gt; None: ...\n    def __new__(cls, embedding: builtins.list[float], document: builtins.str, metadata: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None) -&gt; VectorStoreAddInput: ...\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput.document","title":"document  <code>property</code> <code>writable</code>","text":"<pre><code>document: str\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput.embedding","title":"embedding  <code>property</code> <code>writable</code>","text":"<pre><code>embedding: list[float]\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput.metadata","title":"metadata  <code>property</code> <code>writable</code>","text":"<pre><code>metadata: Optional[dict[str, Any]]\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult","title":"VectorStoreGetResult","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass VectorStoreGetResult:\n    @property\n    def id(self) -&gt; builtins.str: ...\n    @id.setter\n    def id(self, value: builtins.str) -&gt; None: ...\n    @property\n    def document(self) -&gt; builtins.str: ...\n    @document.setter\n    def document(self, value: builtins.str) -&gt; None: ...\n    @property\n    def metadata(self) -&gt; typing.Optional[builtins.dict[builtins.str, typing.Any]]: ...\n    @metadata.setter\n    def metadata(self, value: typing.Optional[builtins.dict[builtins.str, typing.Any]]) -&gt; None: ...\n    @property\n    def embedding(self) -&gt; builtins.list[float]: ...\n    @embedding.setter\n    def embedding(self, value: builtins.list[float]) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.document","title":"document  <code>property</code> <code>writable</code>","text":"<pre><code>document: str\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.embedding","title":"embedding  <code>property</code> <code>writable</code>","text":"<pre><code>embedding: list[float]\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.id","title":"id  <code>property</code> <code>writable</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.metadata","title":"metadata  <code>property</code> <code>writable</code>","text":"<pre><code>metadata: Optional[dict[str, Any]]\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult","title":"VectorStoreRetrieveResult","text":"Source code in <code>ailoy/_core.pyi</code> <pre><code>@typing.final\nclass VectorStoreRetrieveResult:\n    @property\n    def id(self) -&gt; builtins.str: ...\n    @id.setter\n    def id(self, value: builtins.str) -&gt; None: ...\n    @property\n    def document(self) -&gt; builtins.str: ...\n    @document.setter\n    def document(self, value: builtins.str) -&gt; None: ...\n    @property\n    def metadata(self) -&gt; typing.Optional[builtins.dict[builtins.str, typing.Any]]: ...\n    @metadata.setter\n    def metadata(self, value: typing.Optional[builtins.dict[builtins.str, typing.Any]]) -&gt; None: ...\n    @property\n    def distance(self) -&gt; builtins.float: ...\n    @distance.setter\n    def distance(self, value: builtins.float) -&gt; None: ...\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.distance","title":"distance  <code>property</code> <code>writable</code>","text":"<pre><code>distance: float\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.document","title":"document  <code>property</code> <code>writable</code>","text":"<pre><code>document: str\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.id","title":"id  <code>property</code> <code>writable</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.metadata","title":"metadata  <code>property</code> <code>writable</code>","text":"<pre><code>metadata: Optional[dict[str, Any]]\n</code></pre>"}]}