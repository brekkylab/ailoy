"use strict";(self.webpackChunkailoy_docs=self.webpackChunkailoy_docs||[]).push([[6489],{3654:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"tutorial/streaming","title":"Streaming","description":"Agent and its underlying LLM sequentially generate partial strings(tokens) one","source":"@site/docs/tutorial/streaming.mdx","sourceDirName":"tutorial","slug":"/tutorial/streaming","permalink":"/ailoy/docs/tutorial/streaming","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"documentSidebar","previous":{"title":"Image Inputs","permalink":"/ailoy/docs/tutorial/image-inputs"},"next":{"title":"Thinking","permalink":"/ailoy/docs/tutorial/thinking"}}');var s=t(4848),o=t(8453);const i={},r="Streaming",l={},c=[{value:"How to Stream Deltas",id:"how-to-stream-deltas",level:2},{value:"Delta to Completed Message",id:"delta-to-completed-message",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components},{TabItem:t,Tabs:a}=n;return t||p("TabItem",!0),a||p("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"streaming",children:"Streaming"})}),"\n",(0,s.jsx)(n.p,{children:"Agent and its underlying LLM sequentially generate partial strings(tokens) one\nby one, and each generated token is accumulated to form the final output. The\nlonger the generation process, the longer it takes to complete the result, so\nit\u2019s often useful to utilize these intermediate results. Those can be streamed\nas the increments(deltas) of the entire result."}),"\n",(0,s.jsx)(n.p,{children:"This is useful in cases where users may want to stop content generation after\nreviewing the partial results, or for agent-based application developers who\nwant to stream partial results to users in real time to make their applications\nmore responsive."}),"\n",(0,s.jsx)(n.h2,{id:"how-to-stream-deltas",children:"How to Stream Deltas"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"run()"})," method from the ",(0,s.jsx)(n.code,{children:"Agent"}),", which we\u2019ve been using so far, returns\ncomplete messages one by one. In contrast, the ",(0,s.jsx)(n.code,{children:"run_delta()"})," (Python, Rust) or\n",(0,s.jsx)(n.code,{children:"runDelta()"})," (Node.js, Web) method returns a sequence of partial results for\neach LLM generation step, referred to as ",(0,s.jsx)(n.em,{children:"message deltas"}),"."]}),"\n",(0,s.jsxs)(a,{groupId:"code-language",children:[(0,s.jsx)(t,{value:"python",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:"showLineNumbers",children:'import asyncio\n\nimport ailoy as ai\n\n\nasync def main():\n    lm = await ai.LangModel.new_local("Qwen/Qwen3-0.6B")\n    agent = ai.Agent(lm)\n\n    async for resp in agent.run_delta("Please give me a short poem about AI."):\n        if resp.delta.contents and isinstance(resp.delta.contents[0], ai.PartDelta.Text):\n            # print text deltas without line break\n            print(resp.delta.contents[0].text, end="")\n    print()\n\n\nif __name__ == "__main__":\n    asyncio.run(main())\n'})})}),(0,s.jsx)(t,{value:"javascript",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:"showLineNumbers",children:'import * as ai from "ailoy-node";\n\nasync function main() {\n  const lm = await ai.LangModel.newLocal("Qwen/Qwen3-0.6B");\n  const agent = new ai.Agent(lm);\n\n  for await (const resp of agent.runDelta(\n    "Please give me a short poem about AI."\n  )) {\n    if (resp.delta.contents?.[0]?.type === "text") {\n      // print text deltas without line break\n      process.stdout.write(resp.delta.contents[0].text);\n    }\n  }\n  console.log();\n}\n\nmain().catch((err) => {\n  console.error("Error:", err);\n});\n'})})}),(0,s.jsx)(t,{value:"web",label:"JavaScript(Web)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:"web showLineNumbers",children:'import * as ai from "ailoy-web";\n\nasync function main() {\n  const lm = await ai.LangModel.newLocal("Qwen/Qwen3-0.6B");\n  const agent = new ai.Agent(lm);\n\n  for await (const resp of agent.runDelta(\n    "Please give me a short poem about AI."\n  )) {\n    if (resp.delta.contents?.[0]?.type === "text") {\n      console.log(resp.delta.contents[0].text);\n    }\n  }\n  console.log();\n}\n\nmain().catch((err) => {\n  console.error("Error:", err);\n});\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"delta-to-completed-message",children:"Delta to Completed Message"}),"\n",(0,s.jsx)(n.p,{children:"You can also construct a complete message by accumulating message deltas\nsequentially."}),"\n",(0,s.jsxs)(n.p,{children:["A finish reason is provided when the message has been fully generated.\nAccumulate the message deltas until the finish reason appears, then call\n",(0,s.jsx)(n.code,{children:"finish()"})," to produce the complete message."]}),"\n",(0,s.jsxs)(a,{groupId:"code-language",children:[(0,s.jsx)(t,{value:"python",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:"showLineNumbers",children:'import asyncio\n\nimport ailoy as ai\n\n\nasync def main():\n    lm = await ai.LangModel.new_local("Qwen/Qwen3-0.6B")\n    agent = ai.Agent(lm)\n\n    GREEN = "\\x1b[32m"\n    RESET = "\\x1b[0m"\n\n    acc = ai.MessageDelta()  # the base of accumulation\n    async for resp in agent.run_delta("Please give me a short poem about AI."):\n        if resp.delta.contents and isinstance(resp.delta.contents[0], ai.PartDelta.Text):\n            # print text deltas in green\n            print(GREEN + resp.delta.contents[0].text + RESET, end="")\n        acc += resp.delta  # accumulate newly generated delta into the base\n\n        # if finish_reason exists, it means that a whole message is generated.\n        if resp.finish_reason is not None:\n            message = acc.to_message()\n            if isinstance(message.contents[0], ai.Part.Text):\n                print("\\n\\n" + message.contents[0].text)\n            acc = ai.MessageDelta()  # re-initialize the base\n    print()\n\n\nif __name__ == "__main__":\n    asyncio.run(main())\n'})})}),(0,s.jsx)(t,{value:"javascript",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:"showLineNumbers",children:'import * as ai from "ailoy-node";\n\nasync function main() {\n  const lm = await ai.LangModel.newLocal("Qwen/Qwen3-0.6B");\n  const agent = new ai.Agent(lm);\n\n  const GREEN = "\\x1b[32m";\n  const RESET = "\\x1b[0m";\n\n  let acc = {\n    contents: [],\n    tool_calls: [],\n  } as ai.MessageDelta; // the base of accumulation\n  for await (const resp of agent.runDelta(\n    "Please give me a short poem about AI."\n  )) {\n    if (resp.delta.contents?.[0]?.type === "text") {\n      // print text deltas in green\n      process.stdout.write(GREEN + resp.delta.contents[0].text + RESET);\n    }\n    // accumulate newly generated delta into the base\n    acc = ai.accumulateMessageDelta(acc, resp.delta);\n\n    // if finish_reason exists, it means that a whole message is generated.\n    if (resp.finish_reason !== undefined) {\n      const message = ai.finishMessageDelta(acc);\n      if (message.contents?.[0]?.type === "text")\n        console.log("\\n\\n" + message.contents[0].text);\n      acc = {\n        contents: [],\n        tool_calls: [],\n      } as ai.MessageDelta; // re-initialize the base\n    }\n  }\n  console.log();\n}\n\nmain().catch((err) => {\n  console.error("Error:", err);\n});\n'})})}),(0,s.jsx)(t,{value:"web",label:"JavaScript(Web)",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:"web showLineNumbers",children:'import * as ai from "ailoy-web";\n\nasync function main() {\n  const lm = await ai.LangModel.newLocal("Qwen/Qwen3-0.6B");\n  const agent = new ai.Agent(lm);\n\n  const GREEN = "\\x1b[32m";\n  const RESET = "\\x1b[0m";\n\n  let acc = {\n    contents: [],\n    tool_calls: [],\n  }; // the base of accumulation\n  for await (const resp of agent.runDelta(\n    "Please give me a short poem about AI."\n  )) {\n    if (resp.delta.contents?.[0]?.type === "text") {\n      // print text deltas in green\n      console.log(GREEN + resp.delta.contents[0].text + RESET);\n    }\n    // accumulate newly generated delta into the base\n    acc = ai.accumulateMessageDelta(acc, resp.delta);\n\n    // if finish_reason exists, it means that a whole message is generated.\n    if (resp.finish_reason !== undefined) {\n      const message = ai.finishMessageDelta(acc);\n      if (message.contents?.[0]?.type === "text")\n        console.log("\\n\\n" + message.contents[0].text);\n      acc = {\n        contents: [],\n        tool_calls: [],\n      }; // re-initialize the base\n    }\n  }\n  console.log();\n}\n\nmain().catch((err) => {\n  console.error("Error:", err);\n});\n'})})})]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(6540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);