# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

CacheResultT = typing.TypeVar("CacheResultT")

class BaseVectorStore:
    def add_vector(self, input:VectorStoreAddInput) -> builtins.str: ...
    def add_vectors(self, inputs:typing.Sequence[VectorStoreAddInput]) -> builtins.list[builtins.str]: ...
    def get_by_id(self, id:builtins.str) -> typing.Optional[VectorStoreGetResult]: ...
    def get_by_ids(self, ids:typing.Sequence[builtins.str]) -> builtins.list[VectorStoreGetResult]: ...
    def retrieve(self, query_embedding:typing.Sequence[builtins.float], top_k:builtins.int) -> builtins.list[VectorStoreRetrieveResult]: ...
    def batch_retrieve(self, query_embeddings:typing.Sequence[typing.Sequence[builtins.float]], top_k:builtins.int) -> builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...
    def remove_vector(self, id:builtins.str) -> None: ...
    def remove_vectors(self, ids:typing.Sequence[builtins.str]) -> None: ...
    def clear(self) -> None: ...
    def count(self) -> builtins.int: ...

class CacheProgress:
    @property
    def comment(self) -> builtins.str: ...
    @property
    def current(self) -> builtins.int: ...
    @property
    def total(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...

class ChromaVectorStore(BaseVectorStore):
    def __new__(cls, chroma_url:builtins.str, collection_name:builtins.str) -> ChromaVectorStore: ...
    def collection_exists(self, collection_name:builtins.str) -> builtins.bool: ...
    def create_collection(self, collection_name:builtins.str, metadata:typing.Optional[dict]=None) -> dict: ...
    def delete_collection(self, collection_name:builtins.str) -> None: ...
    def add_vector(self, input:VectorStoreAddInput) -> builtins.str: ...
    def add_vectors(self, inputs:typing.Sequence[VectorStoreAddInput]) -> builtins.list[builtins.str]: ...
    def get_by_id(self, id:builtins.str) -> typing.Optional[VectorStoreGetResult]: ...
    def get_by_ids(self, ids:typing.Sequence[builtins.str]) -> builtins.list[VectorStoreGetResult]: ...
    def retrieve(self, query_embedding:typing.Sequence[builtins.float], top_k:builtins.int) -> builtins.list[VectorStoreRetrieveResult]: ...
    def batch_retrieve(self, query_embeddings:typing.Sequence[typing.Sequence[builtins.float]], top_k:builtins.int) -> builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...
    def remove_vector(self, id:builtins.str) -> None: ...
    def remove_vectors(self, ids:typing.Sequence[builtins.str]) -> None: ...
    def clear(self) -> None: ...
    def count(self) -> builtins.int: ...

class EmbeddingModel:
    @classmethod
    def CreateLocal(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> typing.Awaitable[EmbeddingModel]: ...
    @classmethod
    def CreateLocalSync(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> EmbeddingModel: ...
    async def run(self, text:builtins.str) -> builtins.list[builtins.float]: ...
    def run_sync(self, text:builtins.str) -> builtins.list[builtins.float]: ...

class FaissVectorStore(BaseVectorStore):
    def __new__(cls, dim:builtins.int) -> FaissVectorStore: ...
    def add_vector(self, input:VectorStoreAddInput) -> builtins.str: ...
    def add_vectors(self, inputs:typing.Sequence[VectorStoreAddInput]) -> builtins.list[builtins.str]: ...
    def get_by_id(self, id:builtins.str) -> typing.Optional[VectorStoreGetResult]: ...
    def get_by_ids(self, ids:typing.Sequence[builtins.str]) -> builtins.list[VectorStoreGetResult]: ...
    def retrieve(self, query_embedding:typing.Sequence[builtins.float], top_k:builtins.int) -> builtins.list[VectorStoreRetrieveResult]: ...
    def batch_retrieve(self, query_embeddings:typing.Sequence[typing.Sequence[builtins.float]], top_k:builtins.int) -> builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...
    def remove_vector(self, id:builtins.str) -> None: ...
    def remove_vectors(self, ids:typing.Sequence[builtins.str]) -> None: ...
    def clear(self) -> None: ...
    def count(self) -> builtins.int: ...

class Grammar:
    class Plain(Grammar):
        __match_args__ = ((),)
        def __new__(cls) -> Grammar.Plain: ...
    
    class JSON(Grammar):
        __match_args__ = ((),)
        def __new__(cls) -> Grammar.JSON: ...
    
    class JSONSchema(Grammar):
        __match_args__ = ("schema",)
        @property
        def schema(self) -> builtins.str: ...
        def __new__(cls, schema:builtins.str) -> Grammar.JSONSchema: ...
    
    class Regex(Grammar):
        __match_args__ = ("regex",)
        @property
        def regex(self) -> builtins.str: ...
        def __new__(cls, regex:builtins.str) -> Grammar.Regex: ...
    
    class CFG(Grammar):
        __match_args__ = ("cfg",)
        @property
        def cfg(self) -> builtins.str: ...
        def __new__(cls, cfg:builtins.str) -> Grammar.CFG: ...
    
    ...

class InferenceConfig:
    @property
    def think_effort(self) -> typing.Optional[ThinkEffort]: ...
    @property
    def temperature(self) -> typing.Optional[builtins.float]: ...
    @property
    def top_p(self) -> typing.Optional[builtins.float]: ...
    @property
    def max_tokens(self) -> typing.Optional[builtins.int]: ...
    @property
    def grammar(self) -> typing.Optional[Grammar]: ...
    @think_effort.setter
    def think_effort(self, value: typing.Optional[ThinkEffort]) -> None: ...
    @temperature.setter
    def temperature(self, value: typing.Optional[builtins.float]) -> None: ...
    @top_p.setter
    def top_p(self, value: typing.Optional[builtins.float]) -> None: ...
    @max_tokens.setter
    def max_tokens(self, value: typing.Optional[builtins.int]) -> None: ...
    @grammar.setter
    def grammar(self, value: typing.Optional[Grammar]) -> None: ...

class LangModel:
    @classmethod
    def CreateLocal(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> typing.Awaitable[LangModel]: ...
    @classmethod
    def CreateLocalSync(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> LangModel: ...
    @classmethod
    def CreateStreamAPI(cls, spec:APISpecification, model_name:builtins.str, api_key:builtins.str) -> LangModel: ...
    def run(self, messages:typing.Sequence[Message], tools:typing.Sequence[ToolDesc], config:InferenceConfig) -> LanguageModelRunIterator: ...
    def run_sync(self, messages:typing.Sequence[Message], tools:typing.Sequence[ToolDesc], config:InferenceConfig) -> LanguageModelRunSyncIterator: ...

class LanguageModelRunIterator:
    def __aiter__(self) -> LanguageModelRunIterator: ...
    def __anext__(self) -> typing.Awaitable[MessageOutput]: ...

class LanguageModelRunSyncIterator:
    def __iter__(self) -> LanguageModelRunSyncIterator: ...
    def __next__(self) -> MessageOutput: ...

class MCPClient:
    ...

class Message:
    @property
    def role(self) -> Role: ...
    @property
    def contents(self) -> builtins.list[Part]: ...
    @property
    def id(self) -> typing.Optional[builtins.str]: ...
    @property
    def thinking(self) -> typing.Optional[builtins.str]: ...
    @property
    def tool_calls(self) -> typing.Optional[builtins.list[Part]]: ...
    @property
    def signature(self) -> typing.Optional[builtins.str]: ...
    @role.setter
    def role(self, value: Role) -> None: ...
    @contents.setter
    def contents(self, value: builtins.list[Part]) -> None: ...
    @id.setter
    def id(self, value: typing.Optional[builtins.str]) -> None: ...
    @thinking.setter
    def thinking(self, value: typing.Optional[builtins.str]) -> None: ...
    @tool_calls.setter
    def tool_calls(self, value: typing.Optional[builtins.list[Part]]) -> None: ...
    @signature.setter
    def signature(self, value: typing.Optional[builtins.str]) -> None: ...

class MessageDelta:
    @property
    def role(self) -> typing.Optional[Role]: ...
    @property
    def id(self) -> typing.Optional[builtins.str]: ...
    @property
    def thinking(self) -> typing.Optional[builtins.str]: ...
    @property
    def contents(self) -> builtins.list[PartDelta]: ...
    @property
    def tool_calls(self) -> builtins.list[PartDelta]: ...
    @property
    def signature(self) -> typing.Optional[builtins.str]: ...
    @role.setter
    def role(self, value: typing.Optional[Role]) -> None: ...
    @id.setter
    def id(self, value: typing.Optional[builtins.str]) -> None: ...
    @thinking.setter
    def thinking(self, value: typing.Optional[builtins.str]) -> None: ...
    @contents.setter
    def contents(self, value: builtins.list[PartDelta]) -> None: ...
    @tool_calls.setter
    def tool_calls(self, value: builtins.list[PartDelta]) -> None: ...
    @signature.setter
    def signature(self, value: typing.Optional[builtins.str]) -> None: ...

class MessageOutput:
    @property
    def delta(self) -> MessageDelta: ...
    @property
    def finish_reason(self) -> typing.Optional[FinishReason]: ...
    @delta.setter
    def delta(self, value: MessageDelta) -> None: ...
    @finish_reason.setter
    def finish_reason(self, value: typing.Optional[FinishReason]) -> None: ...

class Part:
    class Text(Part):
        __match_args__ = ("text",)
        @property
        def text(self) -> builtins.str: ...
        def __new__(cls, text:builtins.str) -> Part.Text: ...
    
    class Function(Part):
        __match_args__ = ("id", "function",)
        @property
        def id(self) -> typing.Optional[builtins.str]: ...
        @property
        def function(self) -> dict[typing.Literal["name", "args"], typing.Union[str, typing.Any]]: ...
        def __new__(cls, id:typing.Optional[builtins.str], function:dict[typing.Literal["name", "args"], typing.Union[str, typing.Any]]) -> Part.Function: ...
    
    class Value(Part):
        __match_args__ = ("value",)
        @property
        def value(self) -> typing.Any: ...
        def __new__(cls, value:typing.Any) -> Part.Value: ...
    
    class Image(Part):
        __match_args__ = ("image",)
        @property
        def image(self) -> PartImage: ...
        def __new__(cls, image:PartImage) -> Part.Image: ...
    
    ...

class PartDelta:
    class Text(PartDelta):
        __match_args__ = ("text",)
        @property
        def text(self) -> builtins.str: ...
        def __new__(cls, text:builtins.str) -> PartDelta.Text: ...
    
    class Function(PartDelta):
        __match_args__ = ("id", "function",)
        @property
        def id(self) -> typing.Optional[builtins.str]: ...
        @property
        def function(self) -> PartDeltaFunction: ...
        def __new__(cls, id:typing.Optional[builtins.str], function:PartDeltaFunction) -> PartDelta.Function: ...
    
    class Value(PartDelta):
        __match_args__ = ("value",)
        @property
        def value(self) -> typing.Any: ...
        def __new__(cls, value:typing.Any) -> PartDelta.Value: ...
    
    class Null(PartDelta):
        __match_args__ = ((),)
        def __new__(cls) -> PartDelta.Null: ...
    
    ...

class PartDeltaFunction:
    class Verbatim(PartDeltaFunction):
        __match_args__ = ("text",)
        @property
        def text(self) -> builtins.str: ...
        def __new__(cls, text:builtins.str) -> PartDeltaFunction.Verbatim: ...
    
    class WithStringArgs(PartDeltaFunction):
        __match_args__ = ("name", "arguments",)
        @property
        def name(self) -> builtins.str: ...
        @property
        def arguments(self) -> builtins.str: ...
        def __new__(cls, name:builtins.str, arguments:builtins.str) -> PartDeltaFunction.WithStringArgs: ...
    
    class WithParsedArgs(PartDeltaFunction):
        __match_args__ = ("name", "arguments",)
        @property
        def name(self) -> builtins.str: ...
        @property
        def arguments(self) -> typing.Any: ...
        def __new__(cls, name:builtins.str, arguments:typing.Any) -> PartDeltaFunction.WithParsedArgs: ...
    
    ...

class PartImage:
    class Binary(PartImage):
        __match_args__ = ("height", "width", "colorspace", "data",)
        @property
        def height(self) -> builtins.int: ...
        @property
        def width(self) -> builtins.int: ...
        @property
        def colorspace(self) -> typing.Literal["grayscale", "rgb", "rgba"]: ...
        @property
        def data(self) -> typing.Any: ...
        def __new__(cls, height:builtins.int, width:builtins.int, colorspace:typing.Literal["grayscale", "rgb", "rgba"], data:typing.Any) -> PartImage.Binary: ...
    
    ...

class ToolDesc:
    ...

class VectorStoreAddInput:
    @property
    def embedding(self) -> builtins.list[builtins.float]: ...
    @property
    def document(self) -> builtins.str: ...
    @property
    def metadata(self) -> typing.Optional[dict]: ...
    @embedding.setter
    def embedding(self, value: builtins.list[builtins.float]) -> None: ...
    @document.setter
    def document(self, value: builtins.str) -> None: ...
    @metadata.setter
    def metadata(self, value: typing.Optional[dict]) -> None: ...
    def __new__(cls, embedding:typing.Sequence[builtins.float], document:builtins.str, metadata:typing.Optional[dict]=None) -> VectorStoreAddInput: ...
    def to_dict(self) -> dict: ...

class VectorStoreGetResult:
    @property
    def id(self) -> builtins.str: ...
    @property
    def document(self) -> builtins.str: ...
    @property
    def metadata(self) -> typing.Optional[dict]: ...
    @property
    def embedding(self) -> builtins.list[builtins.float]: ...
    def to_dict(self) -> dict: ...
    def __repr__(self) -> builtins.str: ...

class VectorStoreRetrieveResult:
    @property
    def id(self) -> builtins.str: ...
    @property
    def document(self) -> builtins.str: ...
    @property
    def metadata(self) -> typing.Optional[dict]: ...
    @property
    def distance(self) -> builtins.float: ...
    def to_dict(self) -> dict: ...
    def __repr__(self) -> builtins.str: ...

class APISpecification(Enum):
    ChatCompletion = ...
    OpenAI = ...
    Gemini = ...
    Claude = ...
    Responses = ...
    Grok = ...

class FinishReason(Enum):
    Stop = ...
    Length = ...
    ToolCall = ...
    Refusal = ...

class Role(Enum):
    r"""
    The author of a message (or streaming delta) in a chat.
    """
    System = ...
    r"""
    System instructions and constraints provided to the assistant.
    """
    User = ...
    r"""
    Content authored by the end user.
    """
    Assistant = ...
    r"""
    Content authored by the assistant/model.
    """
    Tool = ...
    r"""
    Outputs produced by external tools/functions
    """

class ThinkEffort(Enum):
    Disable = ...
    Enable = ...
    Low = ...
    Medium = ...
    High = ...
