# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

class AgentRunIterator:
    def __aiter__(self) -> AgentRunIterator: ...
    def __anext__(self) -> typing.Any: ...

class AgentRunSyncIterator:
    def __iter__(self) -> AgentRunSyncIterator: ...
    def __next__(self) -> typing.Optional[MessageDelta]: ...

class CacheProgress:
    @property
    def comment(self) -> builtins.str: ...
    @property
    def current(self) -> builtins.int: ...
    @property
    def total(self) -> builtins.int: ...
    @property
    def result(self) -> typing.Optional[typing.Any]: ...

class CacheProgressIterator:
    def __aiter__(self) -> CacheProgressIterator: ...
    def __anext__(self) -> typing.Any: ...

class CacheProgressSyncIterator:
    def __iter__(self) -> CacheProgressSyncIterator: ...
    def __next__(self) -> typing.Optional[CacheProgress]: ...

class LocalLanguageModel:
    @staticmethod
    def create(model_name:builtins.str) -> CacheProgressIterator: ...
    @staticmethod
    def create_sync(model_name:builtins.str) -> CacheProgressSyncIterator: ...
    def run(self, messages:typing.Sequence[Message]) -> AgentRunIterator: ...
    def run_sync(self, messages:typing.Sequence[Message]) -> AgentRunSyncIterator: ...

class Message:
    @property
    def role(self) -> builtins.str: ...
    @property
    def content(self) -> list: ...
    @property
    def reasoning(self) -> list: ...
    @property
    def tool_calls(self) -> list: ...
    @content.setter
    def content(self, value: builtins.list[Part]) -> None: ...
    @reasoning.setter
    def reasoning(self, value: builtins.list[Part]) -> None: ...
    @tool_calls.setter
    def tool_calls(self, value: builtins.list[Part]) -> None: ...
    def __new__(cls, role:builtins.str) -> Message:
        r"""
        Message(role: str)
        role is one of: "system" | "user" | "assistant" | "tool"
        """
    def append_content(self, part:Part) -> None: ...
    def append_reasoning(self, part:Part) -> None: ...
    def append_tool_call(self, part:Part) -> None: ...
    @staticmethod
    def from_json(s:builtins.str) -> Message: ...
    def to_json(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class MessageAggregator:
    ...

class MessageDelta:
    @staticmethod
    def from_json(s:builtins.str) -> MessageDelta: ...
    def to_json(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Part:
    @property
    def part_type(self) -> builtins.str: ...
    @property
    def text(self) -> typing.Optional[builtins.str]: ...
    @property
    def id(self) -> typing.Optional[builtins.str]: ...
    @property
    def function(self) -> typing.Optional[builtins.str]: ...
    @property
    def url(self) -> typing.Optional[builtins.str]: ...
    @property
    def data(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, part_type:builtins.str, *, id:typing.Optional[builtins.str]=None, text:typing.Optional[builtins.str]=None, url:typing.Optional[builtins.str]=None, data:typing.Optional[builtins.str]=None, function:typing.Optional[builtins.str]=None) -> Part:
        r"""
        Part(part_type, *, id=None, text=None, url=None, data=None, function=None)
        
        Examples:
        - Part(part_type="text", text="hello")
        - Part(part_type="image", url="https://example.com/cat.png")
        - Part(part_type="image", data="<base64>")  # 'base64=' alias also accepted
        - Part(part_type="function", function='{"name":"foo","arguments":"{}"}', id="call_1")
        """
    @staticmethod
    def from_json(s:builtins.str) -> Part: ...
    def to_json(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

