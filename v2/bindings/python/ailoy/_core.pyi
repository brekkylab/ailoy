# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

CacheResultT = typing.TypeVar("CacheResultT")

class BaseVectorStore:
    def add_vector(self, input:VectorStoreAddInput) -> builtins.str: ...
    def add_vectors(self, inputs:typing.Sequence[VectorStoreAddInput]) -> builtins.list[builtins.str]: ...
    def get_by_id(self, id:builtins.str) -> typing.Optional[VectorStoreGetResult]: ...
    def get_by_ids(self, ids:typing.Sequence[builtins.str]) -> builtins.list[VectorStoreGetResult]: ...
    def retrieve(self, query_embedding:typing.Sequence[builtins.float], top_k:builtins.int) -> builtins.list[VectorStoreRetrieveResult]: ...
    def batch_retrieve(self, query_embeddings:typing.Sequence[typing.Sequence[builtins.float]], top_k:builtins.int) -> builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...
    def remove_vector(self, id:builtins.str) -> None: ...
    def remove_vectors(self, ids:typing.Sequence[builtins.str]) -> None: ...
    def clear(self) -> None: ...
    def count(self) -> builtins.int: ...

class CacheProgress:
    @property
    def comment(self) -> builtins.str: ...
    @property
    def current(self) -> builtins.int: ...
    @property
    def total(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...

class ChromaVectorStore(BaseVectorStore):
    def __new__(cls, chroma_url:builtins.str, collection_name:builtins.str) -> ChromaVectorStore: ...
    def collection_exists(self, collection_name:builtins.str) -> builtins.bool: ...
    def create_collection(self, collection_name:builtins.str, metadata:typing.Optional[dict]=None) -> dict: ...
    def delete_collection(self, collection_name:builtins.str) -> None: ...
    def add_vector(self, input:VectorStoreAddInput) -> builtins.str: ...
    def add_vectors(self, inputs:typing.Sequence[VectorStoreAddInput]) -> builtins.list[builtins.str]: ...
    def get_by_id(self, id:builtins.str) -> typing.Optional[VectorStoreGetResult]: ...
    def get_by_ids(self, ids:typing.Sequence[builtins.str]) -> builtins.list[VectorStoreGetResult]: ...
    def retrieve(self, query_embedding:typing.Sequence[builtins.float], top_k:builtins.int) -> builtins.list[VectorStoreRetrieveResult]: ...
    def batch_retrieve(self, query_embeddings:typing.Sequence[typing.Sequence[builtins.float]], top_k:builtins.int) -> builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...
    def remove_vector(self, id:builtins.str) -> None: ...
    def remove_vectors(self, ids:typing.Sequence[builtins.str]) -> None: ...
    def clear(self) -> None: ...
    def count(self) -> builtins.int: ...

class EmbeddingModel:
    @classmethod
    def CreateLocal(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> typing.Awaitable[EmbeddingModel]: ...
    @classmethod
    def CreateLocalSync(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> EmbeddingModel: ...
    async def run(self, text:builtins.str) -> builtins.list[builtins.float]: ...
    def run_sync(self, text:builtins.str) -> builtins.list[builtins.float]: ...

class FaissVectorStore(BaseVectorStore):
    def __new__(cls, dim:builtins.int) -> FaissVectorStore: ...
    def add_vector(self, input:VectorStoreAddInput) -> builtins.str: ...
    def add_vectors(self, inputs:typing.Sequence[VectorStoreAddInput]) -> builtins.list[builtins.str]: ...
    def get_by_id(self, id:builtins.str) -> typing.Optional[VectorStoreGetResult]: ...
    def get_by_ids(self, ids:typing.Sequence[builtins.str]) -> builtins.list[VectorStoreGetResult]: ...
    def retrieve(self, query_embedding:typing.Sequence[builtins.float], top_k:builtins.int) -> builtins.list[VectorStoreRetrieveResult]: ...
    def batch_retrieve(self, query_embeddings:typing.Sequence[typing.Sequence[builtins.float]], top_k:builtins.int) -> builtins.list[builtins.list[VectorStoreRetrieveResult]]: ...
    def remove_vector(self, id:builtins.str) -> None: ...
    def remove_vectors(self, ids:typing.Sequence[builtins.str]) -> None: ...
    def clear(self) -> None: ...
    def count(self) -> builtins.int: ...

class Grammar:
    class Plain(Grammar):
        __match_args__ = ((),)
        def __new__(cls) -> Grammar.Plain: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class JSON(Grammar):
        __match_args__ = ((),)
        def __new__(cls) -> Grammar.JSON: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class JSONSchema(Grammar):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> Grammar.JSONSchema: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Regex(Grammar):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> Grammar.Regex: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class CFG(Grammar):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> Grammar.CFG: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    ...

class InferenceConfig:
    @property
    def think_effort(self) -> ThinkEffort: ...
    @property
    def temperature(self) -> typing.Optional[builtins.float]: ...
    @property
    def top_p(self) -> typing.Optional[builtins.float]: ...
    @property
    def max_tokens(self) -> typing.Optional[builtins.int]: ...
    @property
    def grammar(self) -> Grammar: ...
    @think_effort.setter
    def think_effort(self, value: ThinkEffort) -> None: ...
    @temperature.setter
    def temperature(self, value: typing.Optional[builtins.float]) -> None: ...
    @top_p.setter
    def top_p(self, value: typing.Optional[builtins.float]) -> None: ...
    @max_tokens.setter
    def max_tokens(self, value: typing.Optional[builtins.int]) -> None: ...
    @grammar.setter
    def grammar(self, value: Grammar) -> None: ...
    def __new__(cls, think_effort:typing.Optional[ThinkEffort]=None, temperature:typing.Optional[builtins.float]=None, top_p:typing.Optional[builtins.float]=None, max_tokens:typing.Optional[builtins.int]=None) -> InferenceConfig: ...

class LangModel:
    @classmethod
    def CreateLocal(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> typing.Awaitable[LangModel]: ...
    @classmethod
    def CreateLocalSync(cls, model_name:builtins.str, progress_callback:typing.Callable[[CacheProgress], None]=None) -> LangModel: ...
    @classmethod
    def CreateStreamAPI(cls, spec:APISpecification, model_name:builtins.str, api_key:builtins.str) -> LangModel: ...
    def run(self, messages:typing.Sequence[Message], tools:typing.Optional[typing.Sequence[ToolDesc]]=None, config:typing.Optional[InferenceConfig]=None) -> LanguageModelRunIterator: ...
    def run_sync(self, messages:typing.Sequence[Message], tools:typing.Optional[typing.Sequence[ToolDesc]]=None, config:typing.Optional[InferenceConfig]=None) -> LanguageModelRunSyncIterator: ...

class LanguageModelRunIterator:
    def __aiter__(self) -> LanguageModelRunIterator: ...
    def __anext__(self) -> typing.Awaitable[MessageOutput]: ...

class LanguageModelRunSyncIterator:
    def __iter__(self) -> LanguageModelRunSyncIterator: ...
    def __next__(self) -> MessageOutput: ...

class MCPClient:
    def __repr__(self) -> builtins.str: ...
    @classmethod
    def from_stdio(cls, command:builtins.str, args:typing.Sequence[builtins.str]) -> typing.Awaitable[MCPClient]: ...
    @classmethod
    def from_streamable_http(cls, url:builtins.str) -> typing.Awaitable[MCPClient]: ...
    def tools(self) -> builtins.list[Tool]: ...
    def get_tool(self, name:builtins.str) -> typing.Optional[Tool]: ...

class Message:
    @property
    def role(self) -> Role: ...
    @property
    def id(self) -> typing.Optional[builtins.str]: ...
    @property
    def thinking(self) -> builtins.str: ...
    @property
    def contents(self) -> builtins.list[Part]: ...
    @property
    def tool_calls(self) -> builtins.list[Part]: ...
    @property
    def signature(self) -> typing.Optional[builtins.str]: ...
    @property
    def contents(self) -> builtins.list[Part]: ...
    @property
    def thinking(self) -> builtins.str: ...
    @property
    def tool_calls(self) -> builtins.list[Part]: ...
    @property
    def id(self) -> typing.Optional[builtins.str]: ...
    @role.setter
    def role(self, value: Role) -> None: ...
    @id.setter
    def id(self, value: typing.Optional[builtins.str]) -> None: ...
    @thinking.setter
    def thinking(self, value: builtins.str) -> None: ...
    @contents.setter
    def contents(self, value: builtins.list[Part]) -> None: ...
    @tool_calls.setter
    def tool_calls(self, value: builtins.list[Part]) -> None: ...
    @signature.setter
    def signature(self, value: typing.Optional[builtins.str]) -> None: ...
    @contents.setter
    def contents(self, value: builtins.list[Part]) -> None: ...
    @thinking.setter
    def thinking(self, value: builtins.str) -> None: ...
    @tool_calls.setter
    def tool_calls(self, value: builtins.list[Part]) -> None: ...
    @id.setter
    def id(self, value: typing.Optional[builtins.str]) -> None: ...
    def __new__(cls, role:Role, id:typing.Optional[builtins.str]=None, thinking:typing.Optional[builtins.str]=None, contents:typing.Optional[typing.Sequence[Part]]=None, tool_calls:typing.Optional[typing.Sequence[Part]]=None, signature:typing.Optional[builtins.str]=None) -> Message: ...
    def __repr__(self) -> builtins.str: ...
    def append_contents(self, part:Part) -> None: ...
    def append_tool_call(self, part:Part) -> None: ...

class MessageDelta:
    @property
    def role(self) -> typing.Optional[Role]: ...
    @property
    def id(self) -> typing.Optional[builtins.str]: ...
    @property
    def thinking(self) -> builtins.str: ...
    @property
    def contents(self) -> builtins.list[PartDelta]: ...
    @property
    def tool_calls(self) -> builtins.list[PartDelta]: ...
    @property
    def signature(self) -> typing.Optional[builtins.str]: ...
    @role.setter
    def role(self, value: typing.Optional[Role]) -> None: ...
    @id.setter
    def id(self, value: typing.Optional[builtins.str]) -> None: ...
    @thinking.setter
    def thinking(self, value: builtins.str) -> None: ...
    @contents.setter
    def contents(self, value: builtins.list[PartDelta]) -> None: ...
    @tool_calls.setter
    def tool_calls(self, value: builtins.list[PartDelta]) -> None: ...
    @signature.setter
    def signature(self, value: typing.Optional[builtins.str]) -> None: ...
    def __new__(cls, role:typing.Optional[Role]=None, id:typing.Optional[builtins.str]=None, thinking:typing.Optional[builtins.str]=None, contents:typing.Optional[typing.Sequence[PartDelta]]=None, tool_calls:typing.Optional[typing.Sequence[PartDelta]]=None, signature:typing.Optional[builtins.str]=None) -> MessageDelta: ...
    def __repr__(self) -> builtins.str: ...
    def __add__(self, other:MessageDelta) -> MessageDelta: ...
    def to_message(self) -> Message: ...

class MessageOutput:
    @property
    def delta(self) -> MessageDelta: ...
    @property
    def finish_reason(self) -> typing.Optional[FinishReason]: ...
    @property
    def delta(self) -> MessageDelta: ...
    @property
    def finish_reason(self) -> typing.Optional[FinishReason]: ...
    @delta.setter
    def delta(self, value: MessageDelta) -> None: ...
    @finish_reason.setter
    def finish_reason(self, value: typing.Optional[FinishReason]) -> None: ...
    def __repr__(self) -> builtins.str: ...

class Part:
    @property
    def part_type(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Text(Part):
        __match_args__ = ("text",)
        @property
        def text(self) -> builtins.str: ...
        def __new__(cls, text:builtins.str) -> Part.Text: ...
    
    class Function(Part):
        __match_args__ = ("id", "f",)
        @property
        def id(self) -> typing.Optional[builtins.str]: ...
        @property
        def f(self) -> dict[typing.Literal["name", "args"], typing.Union[str, typing.Any]]: ...
        def __new__(cls, id:typing.Optional[builtins.str], f:dict[typing.Literal["name", "args"], typing.Union[str, typing.Any]]) -> Part.Function: ...
    
    class Value(Part):
        __match_args__ = ("value",)
        @property
        def value(self) -> typing.Any: ...
        def __new__(cls, value:typing.Any) -> Part.Value: ...
    
    class Image(Part):
        __match_args__ = ("image",)
        @property
        def image(self) -> PartImage: ...
        def __new__(cls, image:PartImage) -> Part.Image: ...
    

class PartDelta:
    @property
    def part_type(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    class Text(PartDelta):
        __match_args__ = ("text",)
        @property
        def text(self) -> builtins.str: ...
        def __new__(cls, text:builtins.str) -> PartDelta.Text: ...
    
    class Function(PartDelta):
        __match_args__ = ("id", "f",)
        @property
        def id(self) -> typing.Optional[builtins.str]: ...
        @property
        def f(self) -> PartDeltaFunction: ...
        def __new__(cls, id:typing.Optional[builtins.str], f:PartDeltaFunction) -> PartDelta.Function: ...
    
    class Value(PartDelta):
        __match_args__ = ("value",)
        @property
        def value(self) -> typing.Any: ...
        def __new__(cls, value:typing.Any) -> PartDelta.Value: ...
    
    class Null(PartDelta):
        __match_args__ = ((),)
        def __new__(cls) -> PartDelta.Null: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    

class PartDeltaFunction:
    class Verbatim(PartDeltaFunction):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.str: ...
        def __new__(cls, _0:builtins.str) -> PartDeltaFunction.Verbatim: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class WithStringArgs(PartDeltaFunction):
        __match_args__ = ("name", "args",)
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> builtins.str: ...
        def __new__(cls, name:builtins.str, args:builtins.str) -> PartDeltaFunction.WithStringArgs: ...
    
    class WithParsedArgs(PartDeltaFunction):
        __match_args__ = ("name", "args",)
        @property
        def name(self) -> builtins.str: ...
        @property
        def args(self) -> typing.Any: ...
        def __new__(cls, name:builtins.str, args:typing.Any) -> PartDeltaFunction.WithParsedArgs: ...
    
    ...

class PartImage:
    class Binary(PartImage):
        __match_args__ = ("h", "w", "c", "data",)
        @property
        def h(self) -> builtins.int: ...
        @property
        def w(self) -> builtins.int: ...
        @property
        def c(self) -> typing.Literal["grayscale", "rgb", "rgba"]: ...
        @property
        def data(self) -> typing.Any: ...
        def __new__(cls, h:builtins.int, w:builtins.int, c:typing.Literal["grayscale", "rgb", "rgba"], data:typing.Any) -> PartImage.Binary: ...
    
    ...

class Tool:
    @classmethod
    def new_py_function(cls, desc:ToolDesc, func:typing.Any) -> Tool: ...
    def __repr__(self) -> builtins.str: ...
    def __call__(self, **kwargs) -> typing.Awaitable[Any]: ...
    def call(self, **kwargs) -> typing.Awaitable[Any]: ...
    def call_sync(self, **kwargs) -> typing.Any: ...

class ToolDesc:
    @property
    def name(self) -> builtins.str: ...
    @property
    def description(self) -> typing.Optional[builtins.str]: ...
    @property
    def parameters(self) -> dict: ...
    @property
    def returns(self) -> typing.Optional[dict]: ...
    def __new__(cls, name:builtins.str, description:typing.Optional[builtins.str], parameters:dict, *, returns:typing.Optional[dict]=None) -> ToolDesc: ...
    def __repr__(self) -> builtins.str: ...

class VectorStoreAddInput:
    @property
    def embedding(self) -> builtins.list[builtins.float]: ...
    @property
    def document(self) -> builtins.str: ...
    @property
    def metadata(self) -> typing.Optional[dict]: ...
    @embedding.setter
    def embedding(self, value: builtins.list[builtins.float]) -> None: ...
    @document.setter
    def document(self, value: builtins.str) -> None: ...
    @metadata.setter
    def metadata(self, value: typing.Optional[dict]) -> None: ...
    def __new__(cls, embedding:typing.Sequence[builtins.float], document:builtins.str, metadata:typing.Optional[dict]=None) -> VectorStoreAddInput: ...
    def to_dict(self) -> dict: ...

class VectorStoreGetResult:
    @property
    def id(self) -> builtins.str: ...
    @property
    def document(self) -> builtins.str: ...
    @property
    def metadata(self) -> typing.Optional[dict]: ...
    @property
    def embedding(self) -> builtins.list[builtins.float]: ...
    def to_dict(self) -> dict: ...
    def __repr__(self) -> builtins.str: ...

class VectorStoreRetrieveResult:
    @property
    def id(self) -> builtins.str: ...
    @property
    def document(self) -> builtins.str: ...
    @property
    def metadata(self) -> typing.Optional[dict]: ...
    @property
    def distance(self) -> builtins.float: ...
    def to_dict(self) -> dict: ...
    def __repr__(self) -> builtins.str: ...

class APISpecification(Enum):
    ChatCompletion = ...
    OpenAI = ...
    Gemini = ...
    Claude = ...
    Responses = ...
    Grok = ...

class FinishReason(Enum):
    Stop = ...
    Length = ...
    ToolCall = ...
    Refusal = ...

    def __repr__(self) -> builtins.str: ...

class Role(Enum):
    r"""
    The author of a message (or streaming delta) in a chat.
    """
    System = ...
    r"""
    System instructions and constraints provided to the assistant.
    """
    User = ...
    r"""
    Content authored by the end user.
    """
    Assistant = ...
    r"""
    Content authored by the assistant/model.
    """
    Tool = ...
    r"""
    Outputs produced by external tools/functions
    """

    def __repr__(self) -> builtins.str: ...

class ThinkEffort(Enum):
    Disable = ...
    Enable = ...
    Low = ...
    Medium = ...
    High = ...

def ailoy_model_cli() -> None: ...
