{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ailoy Python API Reference","text":""},{"location":"#ailoy.Agent","title":"Agent","text":""},{"location":"#ailoy.Agent.lm","title":"lm  <code>property</code>","text":"<pre><code>lm: LangModel\n</code></pre>"},{"location":"#ailoy.Agent.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: list[Tool]\n</code></pre>"},{"location":"#ailoy.Agent.add_tool","title":"add_tool  <code>method descriptor</code>","text":"<pre><code>add_tool(tool: Tool) -&gt; None\n</code></pre>"},{"location":"#ailoy.Agent.add_tools","title":"add_tools  <code>method descriptor</code>","text":"<pre><code>add_tools(tools: Sequence[Tool]) -&gt; None\n</code></pre>"},{"location":"#ailoy.Agent.remove_tool","title":"remove_tool  <code>method descriptor</code>","text":"<pre><code>remove_tool(tool_name: str) -&gt; None\n</code></pre>"},{"location":"#ailoy.Agent.remove_tools","title":"remove_tools  <code>method descriptor</code>","text":"<pre><code>remove_tools(tool_names: Sequence[str]) -&gt; None\n</code></pre>"},{"location":"#ailoy.Agent.run","title":"run  <code>method descriptor</code>","text":"<pre><code>run(\n    messages: str | list[Message],\n    config: Optional[InferenceConfig] = None,\n) -&gt; AgentRunIterator\n</code></pre>"},{"location":"#ailoy.Agent.run_sync","title":"run_sync  <code>method descriptor</code>","text":"<pre><code>run_sync(\n    messages: str | list[Message],\n    config: Optional[InferenceConfig] = None,\n) -&gt; AgentRunSyncIterator\n</code></pre>"},{"location":"#ailoy.AgentResponse","title":"AgentResponse","text":"<p>The yielded value from agent.run().</p>"},{"location":"#ailoy.AgentResponse.accumulated","title":"accumulated  <code>property</code>","text":"<pre><code>accumulated: Optional[Message]\n</code></pre> <p>Optional accumulated message.</p>"},{"location":"#ailoy.AgentResponse.delta","title":"delta  <code>property</code>","text":"<pre><code>delta: MessageDelta\n</code></pre> <p>The message delta per iteration.</p>"},{"location":"#ailoy.AgentResponse.finish_reason","title":"finish_reason  <code>property</code>","text":"<pre><code>finish_reason: Optional[FinishReason]\n</code></pre> <p>Optional finish reason. If this is Some, the message accumulation is finalized and stored in <code>accumulated</code>.</p>"},{"location":"#ailoy.AgentRunIterator","title":"AgentRunIterator","text":""},{"location":"#ailoy.AgentRunIterator.__aiter__","title":"__aiter__  <code>method descriptor</code>","text":"<pre><code>__aiter__() -&gt; AgentRunIterator\n</code></pre> <p>Return an awaitable, that resolves in asynchronous iterator.</p>"},{"location":"#ailoy.AgentRunIterator.__anext__","title":"__anext__  <code>method descriptor</code>","text":"<pre><code>__anext__() -&gt; Awaitable[AgentResponse]\n</code></pre> <p>Return a value or raise StopAsyncIteration.</p>"},{"location":"#ailoy.AgentRunSyncIterator","title":"AgentRunSyncIterator","text":""},{"location":"#ailoy.AgentRunSyncIterator.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; AgentRunSyncIterator\n</code></pre> <p>Implement iter(self).</p>"},{"location":"#ailoy.AgentRunSyncIterator.__next__","title":"__next__  <code>method descriptor</code>","text":"<pre><code>__next__() -&gt; AgentResponse\n</code></pre> <p>Implement next(self).</p>"},{"location":"#ailoy.CacheProgress","title":"CacheProgress","text":""},{"location":"#ailoy.CacheProgress.comment","title":"comment  <code>property</code>","text":"<pre><code>comment: str\n</code></pre>"},{"location":"#ailoy.CacheProgress.current","title":"current  <code>property</code>","text":"<pre><code>current: int\n</code></pre>"},{"location":"#ailoy.CacheProgress.total","title":"total  <code>property</code>","text":"<pre><code>total: int\n</code></pre>"},{"location":"#ailoy.Document","title":"Document","text":""},{"location":"#ailoy.DocumentPolyfill","title":"DocumentPolyfill","text":"<p>Provides a polyfill for LLMs that do not natively support the Document feature.</p>"},{"location":"#ailoy.DocumentPolyfill.query_message_template","title":"query_message_template  <code>property</code>","text":"<pre><code>query_message_template: Optional[str]\n</code></pre>"},{"location":"#ailoy.DocumentPolyfill.system_message_template","title":"system_message_template  <code>property</code>","text":"<pre><code>system_message_template: Optional[str]\n</code></pre>"},{"location":"#ailoy.EmbeddingModel","title":"EmbeddingModel","text":""},{"location":"#ailoy.EmbeddingModel.new_local","title":"new_local  <code>builtin</code>","text":"<pre><code>new_local(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; Awaitable[EmbeddingModel]\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.new_local_sync","title":"new_local_sync  <code>builtin</code>","text":"<pre><code>new_local_sync(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; EmbeddingModel\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.run","title":"run  <code>method descriptor</code>","text":"<pre><code>run(text: str) -&gt; list[float]\n</code></pre>"},{"location":"#ailoy.EmbeddingModel.run_sync","title":"run_sync  <code>method descriptor</code>","text":"<pre><code>run_sync(text: str) -&gt; list[float]\n</code></pre>"},{"location":"#ailoy.FinishReason","title":"FinishReason","text":"<p>Explains why a language model's streamed generation finished.</p>"},{"location":"#ailoy.FinishReason.Length","title":"Length","text":"<p>               Bases: <code>ailoy._core.FinishReason</code></p>"},{"location":"#ailoy.FinishReason.Refusal","title":"Refusal","text":"<p>               Bases: <code>ailoy._core.FinishReason</code></p>"},{"location":"#ailoy.FinishReason.Refusal.reason","title":"reason  <code>property</code>","text":"<pre><code>reason\n</code></pre>"},{"location":"#ailoy.FinishReason.Stop","title":"Stop","text":"<p>               Bases: <code>ailoy._core.FinishReason</code></p>"},{"location":"#ailoy.FinishReason.ToolCall","title":"ToolCall","text":"<p>               Bases: <code>ailoy._core.FinishReason</code></p>"},{"location":"#ailoy.Grammar","title":"Grammar","text":""},{"location":"#ailoy.Grammar.CFG","title":"CFG","text":"<p>               Bases: <code>ailoy._core.Grammar</code></p>"},{"location":"#ailoy.Grammar.CFG.cfg","title":"cfg  <code>property</code>","text":"<pre><code>cfg: str\n</code></pre>"},{"location":"#ailoy.Grammar.JSON","title":"JSON","text":"<p>               Bases: <code>ailoy._core.Grammar</code></p>"},{"location":"#ailoy.Grammar.JSONSchema","title":"JSONSchema","text":"<p>               Bases: <code>ailoy._core.Grammar</code></p>"},{"location":"#ailoy.Grammar.JSONSchema.schema","title":"schema  <code>property</code>","text":"<pre><code>schema: str\n</code></pre>"},{"location":"#ailoy.Grammar.Plain","title":"Plain","text":"<p>               Bases: <code>ailoy._core.Grammar</code></p>"},{"location":"#ailoy.Grammar.Regex","title":"Regex","text":"<p>               Bases: <code>ailoy._core.Grammar</code></p>"},{"location":"#ailoy.Grammar.Regex.regex","title":"regex  <code>property</code>","text":"<pre><code>regex: str\n</code></pre>"},{"location":"#ailoy.InferenceConfig","title":"InferenceConfig","text":""},{"location":"#ailoy.InferenceConfig.document_polyfill","title":"document_polyfill  <code>property</code>","text":"<pre><code>document_polyfill: Optional[DocumentPolyfill]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.grammar","title":"grammar  <code>property</code>","text":"<pre><code>grammar: Optional[Grammar]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.max_tokens","title":"max_tokens  <code>property</code>","text":"<pre><code>max_tokens: Optional[int]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.temperature","title":"temperature  <code>property</code>","text":"<pre><code>temperature: Optional[float]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.think_effort","title":"think_effort  <code>property</code>","text":"<pre><code>think_effort: Optional[\n    Literal[\"disable\", \"enable\", \"low\", \"medium\", \"high\"]\n]\n</code></pre>"},{"location":"#ailoy.InferenceConfig.top_p","title":"top_p  <code>property</code>","text":"<pre><code>top_p: Optional[float]\n</code></pre>"},{"location":"#ailoy.Knowledge","title":"Knowledge","text":""},{"location":"#ailoy.Knowledge.as_tool","title":"as_tool  <code>method descriptor</code>","text":"<pre><code>as_tool() -&gt; Tool\n</code></pre>"},{"location":"#ailoy.Knowledge.new_vector_store","title":"new_vector_store  <code>builtin</code>","text":"<pre><code>new_vector_store(\n    store: VectorStore, embedding_model: EmbeddingModel\n) -&gt; Knowledge\n</code></pre>"},{"location":"#ailoy.Knowledge.retrieve","title":"retrieve  <code>method descriptor</code>","text":"<pre><code>retrieve(\n    query: str, config: KnowledgeConfig\n) -&gt; list[Document]\n</code></pre>"},{"location":"#ailoy.KnowledgeConfig","title":"KnowledgeConfig","text":""},{"location":"#ailoy.LangModel","title":"LangModel","text":""},{"location":"#ailoy.LangModel.new_local","title":"new_local  <code>builtin</code>","text":"<pre><code>new_local(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; Awaitable[LangModel]\n</code></pre>"},{"location":"#ailoy.LangModel.new_local_sync","title":"new_local_sync  <code>builtin</code>","text":"<pre><code>new_local_sync(\n    model_name: str,\n    progress_callback: Callable[\n        [CacheProgress], None\n    ] = None,\n) -&gt; LangModel\n</code></pre>"},{"location":"#ailoy.LangModel.new_stream_api","title":"new_stream_api  <code>builtin</code>","text":"<pre><code>new_stream_api(\n    spec: Literal[\n        \"ChatCompletion\",\n        \"OpenAI\",\n        \"Gemini\",\n        \"Claude\",\n        \"Responses\",\n        \"Grok\",\n    ],\n    model_name: str,\n    api_key: str,\n) -&gt; LangModel\n</code></pre>"},{"location":"#ailoy.LangModel.run","title":"run  <code>method descriptor</code>","text":"<pre><code>run(\n    messages: str | list[Message],\n    tools: Optional[Sequence[ToolDesc]] = None,\n    documents: Optional[Sequence[Document]] = None,\n    config: Optional[InferenceConfig] = None,\n) -&gt; LangModelRunIterator\n</code></pre>"},{"location":"#ailoy.LangModel.run_sync","title":"run_sync  <code>method descriptor</code>","text":"<pre><code>run_sync(\n    messages: str | list[Message],\n    tools: Optional[Sequence[ToolDesc]] = None,\n    documents: Optional[Sequence[Document]] = None,\n    config: Optional[InferenceConfig] = None,\n) -&gt; LangModelRunSyncIterator\n</code></pre>"},{"location":"#ailoy.LangModelRunIterator","title":"LangModelRunIterator","text":""},{"location":"#ailoy.LangModelRunIterator.__aiter__","title":"__aiter__  <code>method descriptor</code>","text":"<pre><code>__aiter__() -&gt; LangModelRunIterator\n</code></pre> <p>Return an awaitable, that resolves in asynchronous iterator.</p>"},{"location":"#ailoy.LangModelRunIterator.__anext__","title":"__anext__  <code>method descriptor</code>","text":"<pre><code>__anext__() -&gt; Awaitable[MessageOutput]\n</code></pre> <p>Return a value or raise StopAsyncIteration.</p>"},{"location":"#ailoy.LangModelRunSyncIterator","title":"LangModelRunSyncIterator","text":""},{"location":"#ailoy.LangModelRunSyncIterator.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; LangModelRunSyncIterator\n</code></pre> <p>Implement iter(self).</p>"},{"location":"#ailoy.LangModelRunSyncIterator.__next__","title":"__next__  <code>method descriptor</code>","text":"<pre><code>__next__() -&gt; MessageOutput\n</code></pre> <p>Implement next(self).</p>"},{"location":"#ailoy.MCPClient","title":"MCPClient","text":""},{"location":"#ailoy.MCPClient.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: list[Tool]\n</code></pre>"},{"location":"#ailoy.MCPClient.from_stdio","title":"from_stdio  <code>builtin</code>","text":"<pre><code>from_stdio(\n    command: str, args: Sequence[str]\n) -&gt; Awaitable[MCPClient]\n</code></pre>"},{"location":"#ailoy.MCPClient.from_streamable_http","title":"from_streamable_http  <code>builtin</code>","text":"<pre><code>from_streamable_http(url: str) -&gt; Awaitable[MCPClient]\n</code></pre>"},{"location":"#ailoy.MCPClient.get_tool","title":"get_tool  <code>method descriptor</code>","text":"<pre><code>get_tool(name: str) -&gt; Optional[Tool]\n</code></pre>"},{"location":"#ailoy.Message","title":"Message","text":"<p>A chat message generated by a user, model, or tool.</p> <p><code>Message</code> is the concrete, non-streaming container used by the application to store, transmit, or feed structured content into models or tools. It can represent various kinds of messages, including user input, assistant responses, tool-call outputs, or signed thinking metadata.</p> <p>Note that many different kinds of messages can be produced. For example, a language model may internally generate a <code>thinking</code> trace before emitting its final output, in order to improve reasoning accuracy. In other cases, a model may produce function calls \u2014 structured outputs that instruct external tools to perform specific actions.</p> <p>This struct is designed to handle all of these situations in a unified way.</p>"},{"location":"#ailoy.Message--example","title":"Example","text":""},{"location":"#ailoy.Message--rust","title":"Rust","text":"<pre><code>let msg = Message::new(Role::User).with_contents([Part::text(\"hello\")]);\nassert_eq!(msg.role, Role::User);\nassert_eq!(msg.contents.len(), 1);\n</code></pre>"},{"location":"#ailoy.Message.contents","title":"contents  <code>property</code>","text":"<pre><code>contents: list[Part]\n</code></pre> <p>Primary message parts (e.g., text, image, value, or function).</p>"},{"location":"#ailoy.Message.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[str]\n</code></pre> <p>Optional stable identifier for deduplication or threading.</p>"},{"location":"#ailoy.Message.role","title":"role  <code>property</code>","text":"<pre><code>role: Literal['system', 'user', 'assistant', 'tool']\n</code></pre> <p>Author of the message.</p>"},{"location":"#ailoy.Message.signature","title":"signature  <code>property</code>","text":"<pre><code>signature: Optional[str]\n</code></pre> <p>Optional signature for the <code>thinking</code> field.</p> <p>This is only applicable to certain LLM APIs that require a signature as part of the <code>thinking</code> payload.</p>"},{"location":"#ailoy.Message.thinking","title":"thinking  <code>property</code>","text":"<pre><code>thinking: Optional[str]\n</code></pre> <p>Internal \u201cthinking\u201d text used by some models before producing final output.</p>"},{"location":"#ailoy.Message.tool_calls","title":"tool_calls  <code>property</code>","text":"<pre><code>tool_calls: Optional[list[Part]]\n</code></pre> <p>Tool-call parts emitted alongside the main contents.</p>"},{"location":"#ailoy.Message.append_tool_call","title":"append_tool_call  <code>method descriptor</code>","text":"<pre><code>append_tool_call(part: Part) -&gt; None\n</code></pre>"},{"location":"#ailoy.MessageDelta","title":"MessageDelta","text":"<p>A streaming, incremental update to a [<code>Message</code>].</p> <p><code>MessageDelta</code> accumulates partial outputs (text chunks, tool-call fragments, IDs, signatures, etc.) until they can be materialized as a full [<code>Message</code>]. It implements [<code>Delta</code>] to support accumulation.</p>"},{"location":"#ailoy.MessageDelta--accumulation-rules","title":"Accumulation Rules","text":"<ul> <li><code>role</code>: merging two distinct roles fails.</li> <li><code>thinking</code>: concatenated in arrival order.</li> <li><code>contents</code>/<code>tool_calls</code>: last element is accumulated with the incoming delta when both are compatible (e.g., Text+Text, Function+Function with matching ID policy), otherwise appended as a new fragment.</li> <li><code>id</code>/<code>signature</code>: last-writer-wins.</li> </ul>"},{"location":"#ailoy.MessageDelta--finalization","title":"Finalization","text":"<ul> <li><code>finish()</code> converts the accumulated deltas into a fully-formed [<code>Message</code>].   Fails if required fields (e.g., <code>role</code>) are missing or inner deltas cannot be finalized.</li> </ul>"},{"location":"#ailoy.MessageDelta--examples","title":"Examples","text":"<pre><code>let d1 = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: \"Hel\".into() }]);\nlet d2 = MessageDelta::new().with_contents([PartDelta::Text { text: \"lo\".into() }]);\n\nlet merged = d1.accumulate(d2).unwrap();\nlet msg = merged.finish().unwrap();\nassert_eq!(msg.contents[0].as_text().unwrap(), \"Hello\");\n</code></pre>"},{"location":"#ailoy.MessageDelta.contents","title":"contents  <code>property</code>","text":"<pre><code>contents: list[PartDelta]\n</code></pre>"},{"location":"#ailoy.MessageDelta.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[str]\n</code></pre>"},{"location":"#ailoy.MessageDelta.role","title":"role  <code>property</code>","text":"<pre><code>role: Optional[\n    Literal[\"system\", \"user\", \"assistant\", \"tool\"]\n]\n</code></pre>"},{"location":"#ailoy.MessageDelta.signature","title":"signature  <code>property</code>","text":"<pre><code>signature: Optional[str]\n</code></pre>"},{"location":"#ailoy.MessageDelta.thinking","title":"thinking  <code>property</code>","text":"<pre><code>thinking: Optional[str]\n</code></pre>"},{"location":"#ailoy.MessageDelta.tool_calls","title":"tool_calls  <code>property</code>","text":"<pre><code>tool_calls: list[PartDelta]\n</code></pre>"},{"location":"#ailoy.MessageDelta.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value) -&gt; MessageDelta\n</code></pre> <p>Return self+value.</p>"},{"location":"#ailoy.MessageDelta.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"#ailoy.MessageDelta.to_message","title":"to_message  <code>method descriptor</code>","text":"<pre><code>to_message() -&gt; Message\n</code></pre>"},{"location":"#ailoy.MessageOutput","title":"MessageOutput","text":"<p>A container for a streamed message delta and its termination signal.</p> <p>During streaming, <code>delta</code> carries the incremental payload; once a terminal condition is reached, <code>finish_reason</code> may be populated to explain why.</p>"},{"location":"#ailoy.MessageOutput--examples","title":"Examples","text":"<pre><code>let mut out = MessageOutput::new();\nout.delta = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: \"Hi\".into() }]);\nassert!(out.finish_reason.is_none());\n</code></pre>"},{"location":"#ailoy.MessageOutput--lifecycle","title":"Lifecycle","text":"<ul> <li>While streaming: <code>finish_reason</code> is typically <code>None</code>.</li> <li>On completion: <code>finish_reason</code> is set; callers can then <code>finish()</code> the delta to obtain a concrete [<code>Message</code>].</li> </ul>"},{"location":"#ailoy.MessageOutput.delta","title":"delta  <code>property</code>","text":"<pre><code>delta: MessageDelta\n</code></pre>"},{"location":"#ailoy.MessageOutput.finish_reason","title":"finish_reason  <code>property</code>","text":"<pre><code>finish_reason: Optional[FinishReason]\n</code></pre>"},{"location":"#ailoy.Part","title":"Part","text":"<p>Represents a semantically meaningful content unit exchanged between the model and the user.</p> <p>Conceptually, each <code>Part</code> encapsulates a piece of data that contributes to a chat message \u2014 such as text, a function invocation, or an image.  </p> <p>For example, a single message consisting of a sequence like <code>(text..., image, text...)</code> is represented as a <code>Message</code> containing an array of three <code>Part</code> elements.</p> <p>Note that a <code>Part</code> does not carry \"intent\", such as \"reasoning\" or \"tool call\". These higher-level semantics are determined by the context of a [<code>Message</code>].</p>"},{"location":"#ailoy.Part--example","title":"Example","text":""},{"location":"#ailoy.Part--rust","title":"Rust","text":"<pre><code>let part = Part::text(\"Hello, world!\");\nassert!(part.is_text());\n</code></pre>"},{"location":"#ailoy.Part.part_type","title":"part_type  <code>property</code>","text":"<pre><code>part_type: str\n</code></pre>"},{"location":"#ailoy.Part.Function","title":"Function","text":"<p>               Bases: <code>ailoy._core.Part</code></p>"},{"location":"#ailoy.Part.Function.function","title":"function  <code>property</code>","text":"<pre><code>function: PartFunction\n</code></pre>"},{"location":"#ailoy.Part.Function.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[str]\n</code></pre>"},{"location":"#ailoy.Part.Image","title":"Image","text":"<p>               Bases: <code>ailoy._core.Part</code></p>"},{"location":"#ailoy.Part.Image.image","title":"image  <code>property</code>","text":"<pre><code>image: PartImage\n</code></pre>"},{"location":"#ailoy.Part.Text","title":"Text","text":"<p>               Bases: <code>ailoy._core.Part</code></p>"},{"location":"#ailoy.Part.Text.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre>"},{"location":"#ailoy.Part.Value","title":"Value","text":"<p>               Bases: <code>ailoy._core.Part</code></p>"},{"location":"#ailoy.Part.Value.value","title":"value  <code>property</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"#ailoy.Part.image_from_base64","title":"image_from_base64  <code>builtin</code>","text":"<pre><code>image_from_base64(data: str) -&gt; Part\n</code></pre>"},{"location":"#ailoy.Part.image_from_bytes","title":"image_from_bytes  <code>builtin</code>","text":"<pre><code>image_from_bytes(data: bytes) -&gt; Part\n</code></pre>"},{"location":"#ailoy.Part.image_from_url","title":"image_from_url  <code>builtin</code>","text":"<pre><code>image_from_url(url: str) -&gt; Part\n</code></pre>"},{"location":"#ailoy.PartDelta","title":"PartDelta","text":"<p>Represents a partial or incremental update (delta) of a [<code>Part</code>].</p> <p>This type enables composable, streaming updates to message parts. For example, text may be produced token-by-token, or a function call may be emitted gradually as its arguments stream in.</p>"},{"location":"#ailoy.PartDelta--example","title":"Example","text":""},{"location":"#ailoy.PartDelta--rust","title":"Rust","text":"<pre><code>let d1 = PartDelta::Text { text: \"Hel\".into() };\nlet d2 = PartDelta::Text { text: \"lo\".into() };\nlet merged = d1.accumulate(d2).unwrap();\nassert_eq!(merged.to_text().unwrap(), \"Hello\");\n</code></pre>"},{"location":"#ailoy.PartDelta--error-handling","title":"Error Handling","text":"<p>Accumulation or finalization may return an error if incompatible deltas (e.g. mismatched function IDs) are combined or invalid JSON arguments are given.</p>"},{"location":"#ailoy.PartDelta.part_type","title":"part_type  <code>property</code>","text":"<pre><code>part_type: str\n</code></pre>"},{"location":"#ailoy.PartDelta.Function","title":"Function","text":"<p>               Bases: <code>ailoy._core.PartDelta</code></p>"},{"location":"#ailoy.PartDelta.Function.function","title":"function  <code>property</code>","text":"<pre><code>function: PartDeltaFunction\n</code></pre>"},{"location":"#ailoy.PartDelta.Function.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[str]\n</code></pre>"},{"location":"#ailoy.PartDelta.Null","title":"Null","text":"<p>               Bases: <code>ailoy._core.PartDelta</code></p>"},{"location":"#ailoy.PartDelta.Text","title":"Text","text":"<p>               Bases: <code>ailoy._core.PartDelta</code></p>"},{"location":"#ailoy.PartDelta.Text.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre>"},{"location":"#ailoy.PartDelta.Value","title":"Value","text":"<p>               Bases: <code>ailoy._core.PartDelta</code></p>"},{"location":"#ailoy.PartDelta.Value.value","title":"value  <code>property</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction","title":"PartDeltaFunction","text":"<p>Represents an incremental update (delta) of a function part.</p> <p>This type is used during streaming or partial message generation, when function calls are being streamed as text chunks or partial JSON fragments.</p>"},{"location":"#ailoy.PartDeltaFunction--variants","title":"Variants","text":"<ul> <li><code>Verbatim(String)</code> \u2014 Raw text content, typically a partial JSON fragment.</li> <li><code>WithStringArgs { name, arguments }</code> \u2014 Function name and its serialized arguments as strings.</li> <li><code>WithParsedArgs { name, arguments }</code> \u2014 Function name and parsed arguments as a <code>Value</code>.</li> </ul>"},{"location":"#ailoy.PartDeltaFunction--use-case","title":"Use Case","text":"<p>When the model streams out a function call response (e.g., <code>\"function_call\":{\"name\":...}</code>), the incremental deltas can be accumulated until the full function payload is formed.</p>"},{"location":"#ailoy.PartDeltaFunction--example","title":"Example","text":"<pre><code>let delta = PartDeltaFunction::WithStringArgs {\n    name: \"translate\".into(),\n    arguments: r#\"{\"text\":\"hi\"}\"#.into(),\n};\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.Verbatim","title":"Verbatim","text":"<p>               Bases: <code>ailoy._core.PartDeltaFunction</code></p>"},{"location":"#ailoy.PartDeltaFunction.Verbatim.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithParsedArgs","title":"WithParsedArgs","text":"<p>               Bases: <code>ailoy._core.PartDeltaFunction</code></p>"},{"location":"#ailoy.PartDeltaFunction.WithParsedArgs.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: Any\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithParsedArgs.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithStringArgs","title":"WithStringArgs","text":"<p>               Bases: <code>ailoy._core.PartDeltaFunction</code></p>"},{"location":"#ailoy.PartDeltaFunction.WithStringArgs.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: str\n</code></pre>"},{"location":"#ailoy.PartDeltaFunction.WithStringArgs.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.PartFunction","title":"PartFunction","text":"<p>Represents a function call contained within a message part.</p>"},{"location":"#ailoy.PartFunction.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: dict[str, Any]\n</code></pre>"},{"location":"#ailoy.PartFunction.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.PartImage","title":"PartImage","text":"<p>Represents the image data contained in a [<code>Part</code>].</p> <p><code>PartImage</code> provides structured access to image data. Currently, it only implments \"binary\" types.</p>"},{"location":"#ailoy.PartImage--example","title":"Example","text":"<pre><code>let part = Part::image_binary(640, 480, \"rgb\", (0..640*480*3).map(|i| (i % 255) as u8)).unwrap();\n\nif let Some(img) = part.as_image() {\n    assert_eq!(img.height(), 640);\n    assert_eq!(img.width(), 480);\n}\n</code></pre>"},{"location":"#ailoy.PartImage.Binary","title":"Binary","text":"<p>               Bases: <code>ailoy._core.PartImage</code></p>"},{"location":"#ailoy.PartImage.Binary.colorspace","title":"colorspace  <code>property</code>","text":"<pre><code>colorspace: Literal['grayscale', 'rgb', 'rgba']\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.data","title":"data  <code>property</code>","text":"<pre><code>data: Any\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre>"},{"location":"#ailoy.PartImage.Binary.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre>"},{"location":"#ailoy.PartImage.Url","title":"Url","text":"<p>               Bases: <code>ailoy._core.PartImage</code></p>"},{"location":"#ailoy.PartImage.Url.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"#ailoy.Tool","title":"Tool","text":""},{"location":"#ailoy.Tool.__call__","title":"__call__  <code>method descriptor</code>","text":"<pre><code>__call__(*args, **kwargs: Any) -&gt; Awaitable[Any]\n</code></pre> <p>Call self as a function.</p>"},{"location":"#ailoy.Tool.call","title":"call  <code>method descriptor</code>","text":"<pre><code>call(**kwargs: Any) -&gt; Awaitable[Any]\n</code></pre>"},{"location":"#ailoy.Tool.call_sync","title":"call_sync  <code>method descriptor</code>","text":"<pre><code>call_sync(**kwargs: Any) -&gt; Any\n</code></pre>"},{"location":"#ailoy.Tool.get_description","title":"get_description  <code>method descriptor</code>","text":"<pre><code>get_description() -&gt; ToolDesc\n</code></pre>"},{"location":"#ailoy.Tool.new_builtin","title":"new_builtin  <code>builtin</code>","text":"<pre><code>new_builtin(kind: Literal['terminal']) -&gt; Tool\n</code></pre>"},{"location":"#ailoy.Tool.new_py_function","title":"new_py_function","text":"<pre><code>new_py_function(\n    func: Callable, tool_desc: Optional[ToolDesc] = None\n) -&gt; Tool\n</code></pre> Source code in <code>ailoy/_patches.py</code> <pre><code>def new_py_function(\n    cls: Tool, func: Callable, tool_desc: Optional[ToolDesc] = None\n) -&gt; Tool:\n    if tool_desc is None:\n        try:\n            json_schema = get_json_schema(func)\n        except (TypeHintParsingException, DocstringParsingException) as e:\n            raise ValueError(\"Failed to parse docstring\", e)\n\n        tool_desc = ToolDesc(**json_schema.get(\"function\"))\n\n    return cls.__new_py_function__(tool_desc, func)\n</code></pre>"},{"location":"#ailoy.ToolDesc","title":"ToolDesc","text":"<p>Describes a tool (or function) that a language model can invoke.</p> <p><code>ToolDesc</code> defines the schema, behavior, and input/output specification of a callable external function, allowing an LLM to understand how to use it.</p> <p>The primary role of this struct is to describe to the LLM what a tool does, how it can be invoked, and what input (<code>parameters</code>) and output (<code>returns</code>) schemas it expects.</p> <p>The format follows the same schema conventions used by Hugging Face\u2019s <code>transformers</code> library, as well as APIs such as OpenAI and Anthropic. The <code>parameters</code> and <code>returns</code> fields are typically defined using JSON Schema.</p> <p>We provide a builder [<code>ToolDescBuilder</code>] helper for convenient and fluent construction. Please refer to [<code>ToolDescBuilder</code>].</p>"},{"location":"#ailoy.ToolDesc--example","title":"Example","text":"<pre><code>use crate::value::{ToolDescBuilder, to_value};\n\nlet desc = ToolDescBuilder::new(\"temperature\")\n    .description(\"Get the current temperature for a given city\")\n    .parameters(to_value!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"The city name\"\n            },\n            \"unit\": {\n                \"type\": \"string\",\n                \"description\": \"Temperature unit (default: Celsius)\",\n                \"enum\": [\"Celsius\", \"Fahrenheit\"]\n            }\n        },\n        \"required\": [\"location\"]\n    }))\n    .returns(to_value!({\n        \"type\": \"number\"\n    }))\n    .build();\n\nassert_eq!(desc.name, \"temperature\");\n</code></pre>"},{"location":"#ailoy.ToolDesc.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"#ailoy.ToolDesc.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"#ailoy.ToolDesc.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: dict\n</code></pre>"},{"location":"#ailoy.ToolDesc.returns","title":"returns  <code>property</code>","text":"<pre><code>returns: Optional[dict]\n</code></pre>"},{"location":"#ailoy.VectorStore","title":"VectorStore","text":""},{"location":"#ailoy.VectorStore.add_vector","title":"add_vector  <code>method descriptor</code>","text":"<pre><code>add_vector(input: VectorStoreAddInput) -&gt; str\n</code></pre>"},{"location":"#ailoy.VectorStore.add_vectors","title":"add_vectors  <code>method descriptor</code>","text":"<pre><code>add_vectors(\n    inputs: Sequence[VectorStoreAddInput],\n) -&gt; list[str]\n</code></pre>"},{"location":"#ailoy.VectorStore.batch_retrieve","title":"batch_retrieve  <code>method descriptor</code>","text":"<pre><code>batch_retrieve(\n    query_embeddings: Sequence[list[float]], top_k: int\n) -&gt; list[list[VectorStoreRetrieveResult]]\n</code></pre>"},{"location":"#ailoy.VectorStore.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; None\n</code></pre>"},{"location":"#ailoy.VectorStore.count","title":"count  <code>method descriptor</code>","text":"<pre><code>count() -&gt; int\n</code></pre>"},{"location":"#ailoy.VectorStore.get_by_id","title":"get_by_id  <code>method descriptor</code>","text":"<pre><code>get_by_id(id: str) -&gt; Optional[VectorStoreGetResult]\n</code></pre>"},{"location":"#ailoy.VectorStore.get_by_ids","title":"get_by_ids  <code>method descriptor</code>","text":"<pre><code>get_by_ids(\n    ids: Sequence[str],\n) -&gt; list[VectorStoreGetResult]\n</code></pre>"},{"location":"#ailoy.VectorStore.new_chroma","title":"new_chroma  <code>builtin</code>","text":"<pre><code>new_chroma(\n    url: str, collection_name: Optional[str]\n) -&gt; VectorStore\n</code></pre>"},{"location":"#ailoy.VectorStore.new_faiss","title":"new_faiss  <code>builtin</code>","text":"<pre><code>new_faiss(dim: int) -&gt; VectorStore\n</code></pre>"},{"location":"#ailoy.VectorStore.remove_vector","title":"remove_vector  <code>method descriptor</code>","text":"<pre><code>remove_vector(id: str) -&gt; None\n</code></pre>"},{"location":"#ailoy.VectorStore.remove_vectors","title":"remove_vectors  <code>method descriptor</code>","text":"<pre><code>remove_vectors(ids: Sequence[str]) -&gt; None\n</code></pre>"},{"location":"#ailoy.VectorStore.retrieve","title":"retrieve  <code>method descriptor</code>","text":"<pre><code>retrieve(\n    query_embedding: list[float], top_k: int\n) -&gt; list[VectorStoreRetrieveResult]\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput","title":"VectorStoreAddInput","text":""},{"location":"#ailoy.VectorStoreAddInput.document","title":"document  <code>property</code>","text":"<pre><code>document: str\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput.embedding","title":"embedding  <code>property</code>","text":"<pre><code>embedding: list[float]\n</code></pre>"},{"location":"#ailoy.VectorStoreAddInput.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: Optional[dict[str, Any]]\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult","title":"VectorStoreGetResult","text":""},{"location":"#ailoy.VectorStoreGetResult.document","title":"document  <code>property</code>","text":"<pre><code>document: str\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.embedding","title":"embedding  <code>property</code>","text":"<pre><code>embedding: list[float]\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"#ailoy.VectorStoreGetResult.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: Optional[dict[str, Any]]\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult","title":"VectorStoreRetrieveResult","text":""},{"location":"#ailoy.VectorStoreRetrieveResult.distance","title":"distance  <code>property</code>","text":"<pre><code>distance: float\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.document","title":"document  <code>property</code>","text":"<pre><code>document: str\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"#ailoy.VectorStoreRetrieveResult.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: Optional[dict[str, Any]]\n</code></pre>"},{"location":"#ailoy.ailoy_model_cli","title":"ailoy_model_cli  <code>builtin</code>","text":"<pre><code>ailoy_model_cli()\n</code></pre>"}]}