use anyhow::bail;
use serde::{Deserialize, Serialize};

use crate::value::{Delta, Part, PartDelta};

/// The author of a message (or streaming delta) in a chat.
#[derive(
    Clone, Debug, Serialize, Deserialize, PartialEq, Eq, strum::Display, strum::EnumString,
)]
#[serde(rename_all = "lowercase")]
#[strum(serialize_all = "lowercase")]
#[cfg_attr(feature = "python", derive(ailoy_macros::PyStringEnum))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(string_enum = "lowercase"))]
#[cfg_attr(feature = "wasm", derive(tsify::Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub enum Role {
    /// System instructions and constraints provided to the assistant.
    System,
    /// Content authored by the end user.
    User,
    /// Content authored by the assistant/model.
    Assistant,
    /// Outputs produced by external tools/functions
    Tool,
}

/// A chat message generated by a user, model, or tool.
///
/// `Message` is the concrete, non-streaming container used by the application to store, transmit, or feed structured content into models or tools.
/// It can represent various kinds of messages, including user input, assistant responses, tool-call outputs, or signed *thinking* metadata.
///
/// Note that many different kinds of messages can be produced.
/// For example, a language model may internally generate a `thinking` trace before emitting its final output, in order to improve reasoning accuracy.
/// In other cases, a model may produce *function calls* — structured outputs that instruct external tools to perform specific actions.
///
/// This struct is designed to handle all of these situations in a unified way.
///
/// # Example
///
/// ## Rust
/// ```rust
/// let msg = Message::new(Role::User).with_contents([Part::text("hello")]);
/// assert_eq!(msg.role, Role::User);
/// assert_eq!(msg.contents.len(), 1);
/// ```
#[derive(Clone, Debug, Serialize, Deserialize)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
#[cfg_attr(feature = "wasm", derive(tsify::Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub struct Message {
    /// Author of the message.
    pub role: Role,

    /// Primary message parts (e.g., text, image, value, or function).
    pub contents: Vec<Part>,

    /// Optional stable identifier for deduplication or threading.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Internal “thinking” text used by some models before producing final output.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thinking: Option<String>,

    /// Tool-call parts emitted alongside the main contents.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[cfg_attr(feature = "nodejs", napi_derive::napi(js_name = "tool_calls"))]
    pub tool_calls: Option<Vec<Part>>,

    /// Optional signature for the `thinking` field.
    ///
    /// This is only applicable to certain LLM APIs that require a signature as part of the `thinking` payload.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
}

impl Message {
    pub fn new(role: Role) -> Self {
        Self {
            role,
            contents: Vec::new(),
            id: None,
            thinking: None,
            tool_calls: None,
            signature: None,
        }
    }

    pub fn with_id(mut self, id: impl Into<String>) -> Self {
        self.id = Some(id.into());
        self
    }

    pub fn with_thinking(mut self, thinking: impl Into<String>) -> Self {
        self.thinking = Some(thinking.into());
        self
    }

    pub fn with_thinking_signature(
        mut self,
        thinking: impl Into<String>,
        signature: impl Into<String>,
    ) -> Self {
        self.thinking = Some(thinking.into());
        self.signature = Some(signature.into());
        self
    }

    pub fn with_contents(mut self, contents: impl IntoIterator<Item = impl Into<Part>>) -> Self {
        self.contents = contents.into_iter().map(|v| v.into()).collect();
        self
    }

    pub fn with_tool_calls(
        mut self,
        tool_calls: impl IntoIterator<Item = impl Into<Part>>,
    ) -> Self {
        self.tool_calls = Some(tool_calls.into_iter().map(|v| v.into()).collect());
        self
    }
}

/// A streaming, incremental update to a [`Message`].
///
/// `MessageDelta` accumulates partial outputs (text chunks, tool-call fragments, IDs, signatures, etc.) until they can be materialized as a full [`Message`].
/// It implements [`Delta`] to support accumulation.
///
/// # Accumulation Rules
/// - `role`: merging two distinct roles fails.
/// - `thinking`: concatenated in arrival order.
/// - `contents`/`tool_calls`: last element is accumulated with the incoming delta when both are compatible (e.g., Text+Text, Function+Function with matching ID policy), otherwise appended as a new fragment.
/// - `id`/`signature`: last-writer-wins.
///
/// # Finalization
/// - `finish()` converts the accumulated deltas into a fully-formed [`Message`].
///   Fails if required fields (e.g., `role`) are missing or inner deltas cannot be finalized.
///
/// # Examples
/// ```rust
/// let d1 = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: "Hel".into() }]);
/// let d2 = MessageDelta::new().with_contents([PartDelta::Text { text: "lo".into() }]);
///
/// let merged = d1.accumulate(d2).unwrap();
/// let msg = merged.finish().unwrap();
/// assert_eq!(msg.contents[0].as_text().unwrap(), "Hello");
/// ```
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
#[cfg_attr(feature = "wasm", derive(tsify::Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub struct MessageDelta {
    pub role: Option<Role>,
    pub contents: Vec<PartDelta>,
    pub id: Option<String>,
    pub thinking: Option<String>,
    #[cfg_attr(feature = "nodejs", napi_derive::napi(js_name = "tool_calls"))]
    pub tool_calls: Vec<PartDelta>,
    pub signature: Option<String>,
}

impl MessageDelta {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_role(mut self, role: impl Into<Role>) -> Self {
        self.role = Some(role.into());
        self
    }

    pub fn with_id(mut self, id: impl Into<String>) -> Self {
        self.id = Some(id.into());
        self
    }

    pub fn with_thinking(mut self, thinking: impl Into<String>) -> Self {
        self.thinking = Some(thinking.into());
        self
    }

    pub fn with_thinking_signature(
        mut self,
        thinking: impl Into<String>,
        signature: impl Into<String>,
    ) -> Self {
        self.thinking = Some(thinking.into());
        self.signature = Some(signature.into());
        self
    }

    pub fn with_contents(
        mut self,
        contents: impl IntoIterator<Item = impl Into<PartDelta>>,
    ) -> Self {
        self.contents = contents.into_iter().map(|v| v.into()).collect();
        self
    }

    pub fn with_tool_calls(
        mut self,
        tool_calls: impl IntoIterator<Item = impl Into<PartDelta>>,
    ) -> Self {
        self.tool_calls = tool_calls.into_iter().map(|v| v.into()).collect();
        self
    }

    pub fn to_message(self) -> anyhow::Result<Message> {
        self.finish()
    }
}

impl Delta for MessageDelta {
    type Item = Message;
    type Err = anyhow::Error; // TODO: Define custom error for this.

    fn accumulate(self, other: Self) -> anyhow::Result<Self> {
        let Self {
            mut role,
            mut contents,
            mut id,
            mut thinking,
            mut tool_calls,
            mut signature,
        } = self;

        // Merge role
        if let Some(lhs) = &role
            && let Some(rhs) = &other.role
        {
            if lhs != rhs {
                bail!(
                    "Cannot accumulate two message deltas with differenct roles. ({} != {})",
                    lhs,
                    rhs
                );
            };
        } else if let Some(rhs) = other.role {
            role = Some(rhs);
        };

        // Merge ID
        if let Some(id_incoming) = other.id {
            id = Some(id_incoming);
        }

        // Merge think
        if let Some(thinking_rhs) = other.thinking {
            if let Some(mut thinking_lhs) = thinking {
                thinking_lhs.push_str(&thinking_rhs);
                thinking = Some(thinking_lhs);
            } else {
                thinking = Some(thinking_rhs);
            }
        }

        // Merge content
        for part_incoming in other.contents {
            if let Some(part_last) = contents.last() {
                match (part_last, &part_incoming) {
                    (PartDelta::Text { .. }, PartDelta::Text { .. })
                    | (PartDelta::Function { .. }, PartDelta::Function { .. }) => {
                        let v = contents.pop().unwrap().accumulate(part_incoming)?;
                        contents.push(v);
                    }
                    _ => contents.push(part_incoming),
                }
            } else {
                contents.push(part_incoming);
            }
        }

        // Merge tool calls
        for part_incoming in other.tool_calls {
            if let Some(part_last) = tool_calls.last() {
                match (part_last, &part_incoming) {
                    (PartDelta::Text { .. }, PartDelta::Text { .. }) => {
                        let v = tool_calls.pop().unwrap().accumulate(part_incoming)?;
                        tool_calls.push(v);
                    }
                    (PartDelta::Function { id: id1, .. }, PartDelta::Function { id: id2, .. }) => {
                        if let Some(id1) = id1
                            && let Some(id2) = id2
                            && id1 != id2
                        {
                            tool_calls.push(part_incoming);
                        } else {
                            let v = tool_calls.pop().unwrap().accumulate(part_incoming)?;
                            tool_calls.push(v);
                        }
                    }
                    _ => tool_calls.push(part_incoming),
                }
            } else {
                tool_calls.push(part_incoming);
            }
        }

        // Merge signature
        if let Some(sig_incoming) = other.signature {
            signature = Some(sig_incoming);
        }

        // Return
        Ok(Self {
            role,
            contents,
            id,
            thinking,
            tool_calls,
            signature,
        })
    }

    fn finish(self) -> anyhow::Result<Self::Item> {
        let Self {
            role,
            mut contents,
            id,
            thinking,
            mut tool_calls,
            signature,
        } = self;

        let Some(role) = role else {
            bail!("Role not specified")
        };
        let contents = {
            let mut contents_new = Vec::with_capacity(contents.len());
            for v in contents.drain(..) {
                contents_new.push(v.finish()?);
            }
            contents_new
        };
        let tool_calls = {
            let mut tool_calls_new = Vec::with_capacity(tool_calls.len());
            for v in tool_calls.drain(..) {
                tool_calls_new.push(v.finish()?);
            }
            Some(tool_calls_new)
        };
        Ok(Message {
            role,
            contents,
            id,
            thinking,
            tool_calls,
            signature,
        })
    }
}

/// Explains why a language model's streamed generation finished.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass_enum)]
#[cfg_attr(feature = "python", pyo3::pyclass(eq))]
#[cfg_attr(
    feature = "nodejs",
    napi_derive::napi(discriminant_case = "snake_case")
)]
#[cfg_attr(feature = "wasm", derive(tsify::Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub enum FinishReason {
    /// The model stopped naturally (e.g., EOS token or stop sequence).
    Stop {},

    /// Hit the maximum token/length limit.
    Length {},

    /// Stopped because a tool call was produced, waiting for it's execution.
    ToolCall {},

    /// Content was refused/filtered; string provides reason.
    Refusal { reason: String },
}

/// A container for a streamed message delta and its termination signal.
///
/// During streaming, `delta` carries the incremental payload; once a terminal
/// condition is reached, `finish_reason` may be populated to explain why.
///
/// # Examples
/// ```rust
/// let mut out = MessageOutput::new();
/// out.delta = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: "Hi".into() }]);
/// assert!(out.finish_reason.is_none());
/// ```
///
/// # Lifecycle
/// - While streaming: `finish_reason` is typically `None`.
/// - On completion: `finish_reason` is set; callers can then `finish()` the delta to obtain a concrete [`Message`].
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
#[cfg_attr(feature = "wasm", derive(tsify::Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub struct MessageDeltaOutput {
    pub delta: MessageDelta,
    #[cfg_attr(feature = "nodejs", napi_derive::napi(js_name = "finish_reason"))]
    pub finish_reason: Option<FinishReason>,
}

impl MessageDeltaOutput {
    pub fn new() -> Self {
        Self {
            delta: MessageDelta::new(),
            finish_reason: None,
        }
    }
}

#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
#[cfg_attr(feature = "wasm", derive(tsify::Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub struct MessageOutput {
    pub message: Message,
    #[cfg_attr(feature = "nodejs", napi_derive::napi(js_name = "finish_reason"))]
    pub finish_reason: FinishReason,
}

#[cfg(feature = "python")]
pub(crate) mod py {
    use pyo3::{
        Py, PyAny, PyRef, PyResult, Python,
        exceptions::{PyStopAsyncIteration, PyStopIteration},
        pyclass, pymethods,
    };
    use pyo3_stub_gen_derive::*;

    use super::*;

    #[gen_stub_pyclass]
    #[pyclass(unsendable)]
    pub(crate) struct MessageDeltaOutputIterator {
        pub(crate) rx: async_channel::Receiver<anyhow::Result<MessageDeltaOutput>>,
    }

    #[gen_stub_pymethods]
    #[pymethods]
    impl MessageDeltaOutputIterator {
        fn __aiter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        #[gen_stub(override_return_type(type_repr = "typing.Awaitable[MessageDeltaOutput]"))]
        fn __anext__(&self, py: Python<'_>) -> PyResult<Py<PyAny>> {
            let rx: async_channel::Receiver<Result<MessageDeltaOutput, anyhow::Error>> =
                self.rx.clone();
            let fut = async move {
                match rx.recv().await {
                    Ok(res) => res.map_err(Into::into),
                    Err(_) => Err(PyStopAsyncIteration::new_err(())),
                }
            };
            let py_fut = pyo3_async_runtimes::tokio::future_into_py(py, fut)?.unbind();
            Ok(py_fut.into())
        }
    }

    #[gen_stub_pyclass]
    #[pyclass(unsendable)]
    pub(crate) struct MessageDeltaOutputSyncIterator {
        pub(crate) rt: &'static tokio::runtime::Runtime,
        pub(crate) rx: async_channel::Receiver<anyhow::Result<MessageDeltaOutput>>,
    }

    #[gen_stub_pymethods]
    #[pymethods]
    impl MessageDeltaOutputSyncIterator {
        fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        fn __next__(&mut self, py: Python<'_>) -> PyResult<MessageDeltaOutput> {
            let item = py.detach(|| self.rt.block_on(self.rx.recv()));
            match item {
                Ok(res) => res.map_err(Into::into),
                Err(_) => Err(PyStopIteration::new_err(())),
            }
        }
    }

    #[gen_stub_pyclass]
    #[pyclass(unsendable)]
    pub(crate) struct MessageOutputIterator {
        pub(crate) rx: async_channel::Receiver<anyhow::Result<MessageOutput>>,
    }

    #[gen_stub_pymethods]
    #[pymethods]
    impl MessageOutputIterator {
        fn __aiter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        #[gen_stub(override_return_type(type_repr = "typing.Awaitable[MessageOutput]"))]
        fn __anext__(&self, py: Python<'_>) -> PyResult<Py<PyAny>> {
            let rx: async_channel::Receiver<Result<MessageOutput, anyhow::Error>> = self.rx.clone();
            let fut = async move {
                match rx.recv().await {
                    Ok(res) => res.map_err(Into::into),
                    Err(_) => Err(PyStopAsyncIteration::new_err(())),
                }
            };
            let py_fut = pyo3_async_runtimes::tokio::future_into_py(py, fut)?.unbind();
            Ok(py_fut.into())
        }
    }

    #[gen_stub_pyclass]
    #[pyclass(unsendable)]
    pub(crate) struct MessageOutputSyncIterator {
        pub(crate) rt: &'static tokio::runtime::Runtime,
        pub(crate) rx: async_channel::Receiver<anyhow::Result<MessageOutput>>,
    }

    #[gen_stub_pymethods]
    #[pymethods]
    impl MessageOutputSyncIterator {
        fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        fn __next__(&mut self, py: Python<'_>) -> PyResult<MessageOutput> {
            let item = py.detach(|| self.rt.block_on(self.rx.recv()));
            match item {
                Ok(res) => res.map_err(Into::into),
                Err(_) => Err(PyStopIteration::new_err(())),
            }
        }
    }
}

#[cfg(feature = "nodejs")]
pub(crate) mod node {
    use std::sync::Arc;

    use futures::lock::Mutex;
    use napi::{Error, JsSymbol, Status, bindgen_prelude::*};
    use napi_derive::napi;
    use tokio::sync::mpsc;

    use super::*;

    #[derive(Clone)]
    #[napi]
    pub struct MessageDeltaOutputIterator {
        pub(crate) rx: Arc<Mutex<mpsc::UnboundedReceiver<anyhow::Result<MessageDeltaOutput>>>>,
    }

    #[napi(object)]
    pub struct MessageDeltaOutputIteratorResult {
        pub value: Option<MessageDeltaOutput>,
        pub done: bool,
    }

    #[napi]
    impl MessageDeltaOutputIterator {
        #[napi(js_name = "[Symbol.asyncIterator]")]
        pub fn async_iterator(&self) -> &Self {
            // This is a dummy function to add typing for Symbol.asyncIterator
            self
        }

        #[napi]
        pub async unsafe fn next(&mut self) -> napi::Result<MessageDeltaOutputIteratorResult> {
            let mut rx = self.rx.lock().await;
            match rx.recv().await {
                Some(Ok(output)) => Ok(MessageDeltaOutputIteratorResult {
                    value: Some(output.into()),
                    done: false,
                }),
                Some(Err(e)) => Err(Error::new(Status::GenericFailure, e)),
                None => Ok(MessageDeltaOutputIteratorResult {
                    value: None,
                    done: true,
                }),
            }
        }
    }

    impl MessageDeltaOutputIterator {
        /// This returns an object with \[Symbol.asyncIterator\], which is not directly injected by napi-rs.
        pub(crate) fn to_async_iterator<'a>(self, env: Env) -> napi::Result<Object<'a>> {
            let mut obj = Object::new(&env)?;

            let global = env.get_global()?;
            let symbol: Function = global.get_named_property("Symbol")?;
            let symbol_async_iterator: JsSymbol = symbol.get_named_property("asyncIterator")?;

            let func: Function<(), MessageDeltaOutputIterator> =
                env.create_function_from_closure("asyncIterator", move |_| Ok(self.clone()))?;

            obj.set_property(symbol_async_iterator, func)?;

            Ok(obj)
        }
    }

    #[derive(Clone)]
    #[napi]
    pub struct MessageOutputIterator {
        pub(crate) rx: Arc<Mutex<mpsc::UnboundedReceiver<anyhow::Result<MessageOutput>>>>,
    }

    #[napi(object)]
    pub struct MessageOutputIteratorResult {
        pub value: Option<MessageOutput>,
        pub done: bool,
    }

    #[napi]
    impl MessageOutputIterator {
        #[napi(js_name = "[Symbol.asyncIterator]")]
        pub fn async_iterator(&self) -> &Self {
            // This is a dummy function to add typing for Symbol.asyncIterator
            self
        }

        #[napi]
        pub async unsafe fn next(&mut self) -> napi::Result<MessageOutputIteratorResult> {
            let mut rx = self.rx.lock().await;
            match rx.recv().await {
                Some(Ok(output)) => Ok(MessageOutputIteratorResult {
                    value: Some(output.into()),
                    done: false,
                }),
                Some(Err(e)) => Err(Error::new(Status::GenericFailure, e)),
                None => Ok(MessageOutputIteratorResult {
                    value: None,
                    done: true,
                }),
            }
        }
    }

    impl MessageOutputIterator {
        /// This returns an object with \[Symbol.asyncIterator\], which is not directly injected by napi-rs.
        pub(crate) fn to_async_iterator<'a>(self, env: Env) -> napi::Result<Object<'a>> {
            let mut obj = Object::new(&env)?;

            let global = env.get_global()?;
            let symbol: Function = global.get_named_property("Symbol")?;
            let symbol_async_iterator: JsSymbol = symbol.get_named_property("asyncIterator")?;

            let func: Function<(), MessageOutputIterator> =
                env.create_function_from_closure("asyncIterator", move |_| Ok(self.clone()))?;

            obj.set_property(symbol_async_iterator, func)?;

            Ok(obj)
        }
    }
}
