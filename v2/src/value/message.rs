use anyhow::bail;
use serde::{Deserialize, Serialize};

use crate::value::{Delta, Part, PartDelta};

/// The author of a message (or streaming delta) in a chat.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, strum::Display)]
#[serde(rename_all = "lowercase")]
#[strum(serialize_all = "lowercase")]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass_enum)]
#[cfg_attr(feature = "python", pyo3::pyclass(eq))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(string_enum))]
pub enum Role {
    /// System instructions and constraints provided to the assistant.
    System,
    /// Content authored by the end user.
    User,
    /// Content authored by the assistant/model.
    Assistant,
    /// Outputs produced by external tools/functions
    Tool,
}

/// A chat message generated by a user, model, or tool.
///
/// `Message` is the concrete, non-streaming container used by the application to store, transmit, or feed structured content into models or tools.
/// It can represent various kinds of messages, including user input, assistant responses, tool-call outputs, or signed *thinking* metadata.
///
/// Note that many different kinds of messages can be produced.
/// For example, a language model may internally generate a `thinking` trace before emitting its final output, in order to improve reasoning accuracy.
/// In other cases, a model may produce *function calls* — structured outputs that instruct external tools to perform specific actions.
///
/// This struct is designed to handle all of these situations in a unified way.
///
/// # Example
///
/// ## Rust
/// ```rust
/// let msg = Message::new(Role::User).with_contents([Part::text("hello")]);
/// assert_eq!(msg.role, Role::User);
/// assert_eq!(msg.contents.len(), 1);
/// ```
#[derive(Clone, Debug, Serialize, Deserialize)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
pub struct Message {
    /// Author of the message.
    pub role: Role,

    /// Optional stable identifier for deduplication or threading.
    pub id: Option<String>,

    /// Internal “thinking” text used by some models before producing final output.
    pub thinking: String,

    /// Primary message parts (e.g., text, image, value, or function).
    pub contents: Vec<Part>,

    /// Tool-call parts emitted alongside the main contents.
    pub tool_calls: Vec<Part>,

    /// Optional signature for the `thinking` field.
    ///
    /// This is only applicable to certain LLM APIs that require a signature as part of the `thinking` payload.
    pub signature: Option<String>,
}

impl Message {
    pub fn new(role: Role) -> Self {
        Self {
            role,
            id: None,
            thinking: String::new(),
            contents: Vec::new(),
            tool_calls: Vec::new(),
            signature: None,
        }
    }

    pub fn with_id(mut self, id: impl Into<String>) -> Self {
        self.id = Some(id.into());
        self
    }

    pub fn with_thinking(mut self, thinking: impl Into<String>) -> Self {
        self.thinking = thinking.into();
        self
    }

    pub fn with_thinking_signature(
        mut self,
        thinking: impl Into<String>,
        signature: impl Into<String>,
    ) -> Self {
        self.thinking = thinking.into();
        self.signature = Some(signature.into());
        self
    }

    pub fn with_contents(mut self, contents: impl IntoIterator<Item = impl Into<Part>>) -> Self {
        self.contents = contents.into_iter().map(|v| v.into()).collect();
        self
    }

    pub fn with_tool_calls(
        mut self,
        tool_calls: impl IntoIterator<Item = impl Into<Part>>,
    ) -> Self {
        self.tool_calls = tool_calls.into_iter().map(|v| v.into()).collect();
        self
    }
}

/// A streaming, incremental update to a [`Message`].
///
/// `MessageDelta` accumulates partial outputs (text chunks, tool-call fragments, IDs, signatures, etc.) until they can be materialized as a full [`Message`].
/// It implements [`Delta`] to support associative aggregation.
///
/// # Aggregation Rules
/// - `role`: merging two distinct roles fails.
/// - `thinking`: concatenated in arrival order.
/// - `contents`/`tool_calls`: last element is aggregated with the incoming delta when both are compatible (e.g., Text+Text, Function+Function with matching ID policy), otherwise appended as a new fragment.
/// - `id`/`signature`: last-writer-wins.
///
/// # Finalization
/// - `finish()` converts the accumulated deltas into a fully-formed [`Message`].
///   Fails if required fields (e.g., `role`) are missing or inner deltas cannot be finalized.
///
/// # Examples
/// ```rust
/// let d1 = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: "Hel".into() }]);
/// let d2 = MessageDelta::new().with_contents([PartDelta::Text { text: "lo".into() }]);
///
/// let merged = d1.aggregate(d2).unwrap();
/// let msg = merged.finish().unwrap();
/// assert_eq!(msg.contents[0].as_text().unwrap(), "Hello");
/// ```
#[derive(Clone, Debug, Default)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
pub struct MessageDelta {
    pub role: Option<Role>,
    pub id: Option<String>,
    pub thinking: String,
    pub contents: Vec<PartDelta>,
    pub tool_calls: Vec<PartDelta>,
    pub signature: Option<String>,
}

impl MessageDelta {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_role(mut self, role: impl Into<Role>) -> Self {
        self.role = Some(role.into());
        self
    }

    pub fn with_id(mut self, id: impl Into<String>) -> Self {
        self.id = Some(id.into());
        self
    }

    pub fn with_thinking(mut self, thinking: impl Into<String>) -> Self {
        self.thinking = thinking.into();
        self
    }

    pub fn with_thinking_signature(
        mut self,
        thinking: impl Into<String>,
        signature: impl Into<String>,
    ) -> Self {
        self.thinking = thinking.into();
        self.signature = Some(signature.into());
        self
    }

    pub fn with_contents(
        mut self,
        contents: impl IntoIterator<Item = impl Into<PartDelta>>,
    ) -> Self {
        self.contents = contents.into_iter().map(|v| v.into()).collect();
        self
    }

    pub fn with_tool_calls(
        mut self,
        tool_calls: impl IntoIterator<Item = impl Into<PartDelta>>,
    ) -> Self {
        self.tool_calls = tool_calls.into_iter().map(|v| v.into()).collect();
        self
    }

    pub fn to_message(self) -> anyhow::Result<Message> {
        self.finish()
    }
}

impl Delta for MessageDelta {
    type Item = Message;
    type Err = anyhow::Error; // TODO: Define custom error for this.

    fn aggregate(self, other: Self) -> anyhow::Result<Self> {
        let Self {
            mut role,
            mut id,
            mut thinking,
            mut contents,
            mut tool_calls,
            mut signature,
        } = self;

        // Merge role
        if let Some(lhs) = &role
            && let Some(rhs) = &other.role
        {
            if lhs != rhs {
                bail!(
                    "Cannot aggregate two message deltas with differenct roles. ({} != {})",
                    lhs,
                    rhs
                );
            };
        } else if let Some(rhs) = other.role {
            role = Some(rhs);
        };

        // Merge ID
        if let Some(id_incoming) = other.id {
            id = Some(id_incoming);
        }

        // Merge think
        if !other.thinking.is_empty() {
            thinking.push_str(&other.thinking);
        }

        // Merge content
        for part_incoming in other.contents {
            if let Some(part_last) = contents.last() {
                match (part_last, &part_incoming) {
                    (PartDelta::Text { .. }, PartDelta::Text { .. })
                    | (PartDelta::Function { .. }, PartDelta::Function { .. }) => {
                        let v = contents.pop().unwrap().aggregate(part_incoming)?;
                        contents.push(v);
                    }
                    _ => contents.push(part_incoming),
                }
            } else {
                contents.push(part_incoming);
            }
        }

        // Merge tool calls
        for part_incoming in other.tool_calls {
            if let Some(part_last) = tool_calls.last() {
                match (part_last, &part_incoming) {
                    (PartDelta::Text { .. }, PartDelta::Text { .. }) => {
                        let v = tool_calls.pop().unwrap().aggregate(part_incoming)?;
                        tool_calls.push(v);
                    }
                    (PartDelta::Function { id: id1, .. }, PartDelta::Function { id: id2, .. }) => {
                        if let Some(id1) = id1
                            && let Some(id2) = id2
                            && id1 != id2
                        {
                            tool_calls.push(part_incoming);
                        } else {
                            let v = tool_calls.pop().unwrap().aggregate(part_incoming)?;
                            tool_calls.push(v);
                        }
                    }
                    _ => tool_calls.push(part_incoming),
                }
            } else {
                tool_calls.push(part_incoming);
            }
        }

        // Merge signature
        if let Some(sig_incoming) = other.signature {
            signature = Some(sig_incoming);
        }

        // Return
        Ok(Self {
            role,
            thinking,
            id,
            contents,
            tool_calls,
            signature,
        })
    }

    fn finish(self) -> anyhow::Result<Self::Item> {
        let Self {
            role,
            id,
            thinking,
            mut contents,
            mut tool_calls,
            signature,
        } = self;

        let Some(role) = role else {
            bail!("Role not specified")
        };
        let contents = {
            let mut contents_new = Vec::with_capacity(contents.len());
            for v in contents.drain(..) {
                contents_new.push(v.finish()?);
            }
            contents_new
        };
        let tool_calls = {
            let mut tool_calls_new = Vec::with_capacity(tool_calls.len());
            for v in tool_calls.drain(..) {
                tool_calls_new.push(v.finish()?);
            }
            tool_calls_new
        };
        Ok(Message {
            role,
            id,
            thinking,
            contents,
            tool_calls,
            signature,
        })
    }
}

/// Explains why a language model's streamed generation finished.
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass_enum)]
#[cfg_attr(feature = "python", pyo3::pyclass(eq))]
#[cfg_attr(feature = "nodejs", napi_derive::napi)]
pub enum FinishReason {
    /// The model stopped naturally (e.g., EOS token or stop sequence).
    Stop(),

    /// Hit the maximum token/length limit.
    Length(),

    /// Stopped because a tool call was produced, waiting for it's execution.
    ToolCall(),

    /// Content was refused/filtered; string provides reason.
    Refusal(String),
}

/// A container for a streamed message delta and its termination signal.
///
/// During streaming, `delta` carries the incremental payload; once a terminal
/// condition is reached, `finish_reason` may be populated to explain why.
///
/// # Examples
/// ```rust
/// let mut out = MessageOutput::new();
/// out.delta = MessageDelta::new().with_role(Role::Assistant).with_contents([PartDelta::Text { text: "Hi".into() }]);
/// assert!(out.finish_reason.is_none());
/// ```
///
/// # Lifecycle
/// - While streaming: `finish_reason` is typically `None`.
/// - On completion: `finish_reason` is set; callers can then `finish()` the delta to obtain a concrete [`Message`].
#[derive(Clone, Debug, Default)]
#[cfg_attr(feature = "python", pyo3_stub_gen_derive::gen_stub_pyclass)]
#[cfg_attr(feature = "python", pyo3::pyclass(get_all, set_all))]
#[cfg_attr(feature = "nodejs", napi_derive::napi(object))]
pub struct MessageOutput {
    pub delta: MessageDelta,
    pub finish_reason: Option<FinishReason>,
}

impl MessageOutput {
    pub fn new() -> Self {
        Self {
            delta: MessageDelta::new(),
            finish_reason: None,
        }
    }
}
